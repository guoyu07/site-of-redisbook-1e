<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>连锁更新 &mdash; Redis 设计与实现</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Redis 设计与实现" href="../../index.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>连锁更新<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>前面说过，
每个节点的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性都记录了前一个节点的长度：</p>
<ul class="simple">
<li>如果前一节点的长度小于 <code class="docutils literal"><span class="pre">254</span></code> 字节，
那么 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性需要用 <code class="docutils literal"><span class="pre">1</span></code> 字节长的空间来保存这个长度值。</li>
<li>如果前一节点的长度大于等于 <code class="docutils literal"><span class="pre">254</span></code> 字节，
那么 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性需要用 <code class="docutils literal"><span class="pre">5</span></code> 字节长的空间来保存这个长度值。</li>
</ul>
<p>现在，
考虑这样一种情况：
在一个压缩列表中，
有多个连续的、长度介于 <code class="docutils literal"><span class="pre">250</span></code> 字节到 <code class="docutils literal"><span class="pre">253</span></code> 字节之间的节点 <code class="docutils literal"><span class="pre">e1</span></code> 至 <code class="docutils literal"><span class="pre">eN</span></code> ，
如图 7-11 所示。</p>
<p class="graphviz">
<img src="../../_images/graphviz-734bbf5a1fa692f6d7a69edbbcf49bf337c1a061.png" alt="digraph {

    label = &quot;\n 图 7-11    包含节点 e1 至 eN 的压缩列表&quot;;

    node [shape = record];

    ziplist [label = &quot; zlbytes| zltail | zllen | e1 | e2 | e3 | ... | eN | zlend &quot;];

}" />
</p>
<p>因为 <code class="docutils literal"><span class="pre">e1</span></code> 至 <code class="docutils literal"><span class="pre">eN</span></code> 的所有节点的长度都小于 <code class="docutils literal"><span class="pre">254</span></code> 字节，
所以记录这些节点的长度只需要 <code class="docutils literal"><span class="pre">1</span></code> 字节长的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性，
换句话说，
<code class="docutils literal"><span class="pre">e1</span></code> 至 <code class="docutils literal"><span class="pre">eN</span></code> 的所有节点的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性都是 <code class="docutils literal"><span class="pre">1</span></code> 字节长的。</p>
<p>这时，
如果我们将一个长度大于等于 <code class="docutils literal"><span class="pre">254</span></code> 字节的新节点 <code class="docutils literal"><span class="pre">new</span></code> 设置为压缩列表的表头节点，
那么 <code class="docutils literal"><span class="pre">new</span></code> 将成为 <code class="docutils literal"><span class="pre">e1</span></code> 的前置节点，
如图 7-12 所示。</p>
<p class="graphviz">
<img src="../../_images/graphviz-a403378a625e791d8af8bb60c7ebfce466233eee.png" alt="digraph {

    label = &quot;\n 图 7-12    添加新节点到压缩列表&quot;;

    rankdir = BT;

    node [shape = record];

    ziplist [label = &quot; zlbytes | zltail | zllen | &lt;new&gt; new | e1 | e2 | e3 | ... | eN | zlend &quot;];

    p [label = &quot;添加新节点&quot;, shape = plaintext];

    p -&gt; ziplist:new;

}" />
</p>
<p>因为 <code class="docutils literal"><span class="pre">e1</span></code> 的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性仅长 <code class="docutils literal"><span class="pre">1</span></code> 字节，
它没办法保存新节点 <code class="docutils literal"><span class="pre">new</span></code> 的长度，
所以程序将对压缩列表执行空间重分配操作，
并将 <code class="docutils literal"><span class="pre">e1</span></code> 节点的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性从原来的 <code class="docutils literal"><span class="pre">1</span></code> 字节长扩展为 <code class="docutils literal"><span class="pre">5</span></code> 字节长。</p>
<p>现在，
麻烦的事情来了 ——
<code class="docutils literal"><span class="pre">e1</span></code> 原本的长度介于 <code class="docutils literal"><span class="pre">250</span></code> 字节至 <code class="docutils literal"><span class="pre">253</span></code> 字节之间，
在为 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性新增四个字节的空间之后，
<code class="docutils literal"><span class="pre">e1</span></code> 的长度就变成了介于 <code class="docutils literal"><span class="pre">254</span></code> 字节至 <code class="docutils literal"><span class="pre">257</span></code> 字节之间，
而这种长度使用 <code class="docutils literal"><span class="pre">1</span></code> 字节长的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性是没办法保存的。</p>
<p>因此，
为了让 <code class="docutils literal"><span class="pre">e2</span></code> 的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性可以记录下 <code class="docutils literal"><span class="pre">e1</span></code> 的长度，
程序需要再次对压缩列表执行空间重分配操作，
并将 <code class="docutils literal"><span class="pre">e2</span></code> 节点的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性从原来的 <code class="docutils literal"><span class="pre">1</span></code> 字节长扩展为 <code class="docutils literal"><span class="pre">5</span></code> 字节长。</p>
<p>正如扩展 <code class="docutils literal"><span class="pre">e1</span></code> 引发了对 <code class="docutils literal"><span class="pre">e2</span></code> 的扩展一样，
扩展 <code class="docutils literal"><span class="pre">e2</span></code> 也会引发对 <code class="docutils literal"><span class="pre">e3</span></code> 的扩展，
而扩展 <code class="docutils literal"><span class="pre">e3</span></code> 又会引发对 <code class="docutils literal"><span class="pre">e4</span></code> 的扩展……为了让每个节点的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性都符合压缩列表对节点的要求，
程序需要不断地对压缩列表执行空间重分配操作，
直到 <code class="docutils literal"><span class="pre">eN</span></code> 为止。</p>
<p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update），
图 7-13 展示了这一过程。</p>
<p class="graphviz">
<img src="../../_images/graphviz-7d01d41bb23475dbd0e3d7d8a1e3f4c9c300ee25.png" alt="digraph {

    rankdir = BT;

    node [shape = record];

    ziplist [label = &quot; zlbytes | zltail | zllen | &lt;new&gt; new | &lt;e1&gt; e1 | &lt;e2&gt; e2 | &lt;e3&gt; e3 | ... | &lt;en&gt; eN | zlend &quot;];

    p [label = &quot;扩展 e1 \n并引发对 e2 的扩展&quot;, shape = plaintext];

    p -&gt; ziplist:e1;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-7cf42c1bb5595457d19f0d8ff709d65c49ba8278.png" alt="digraph {

    rankdir = BT;

    node [shape = record];

    ziplist [label = &quot; zlbytes | zltail | zllen | &lt;new&gt; new | &lt;e1&gt; e1 | &lt;e2&gt; e2 | &lt;e3&gt; e3 | ... | &lt;en&gt; eN | zlend &quot;];

    p [label = &quot;扩展 e2 \n并引发对 e3 的扩展&quot;, shape = plaintext];

    p -&gt; ziplist:e2;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-f7d3e0af6174a2845a1d31773b96b5912de73b3f.png" alt="digraph {

    rankdir = BT;

    node [shape = record];

    ziplist [label = &quot; zlbytes | zltail | zllen | &lt;new&gt; new | &lt;e1&gt; e1 | &lt;e2&gt; e2 | &lt;e3&gt; e3 | ... | &lt;en&gt; eN | zlend &quot;];

    p [label = &quot;扩展 e3 \n并引发对 e4 的扩展&quot;, shape = plaintext];

    p -&gt; ziplist:e3;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-b51a8a86bd07d77656f0a2e6be414473f7cabeeb.png" alt="digraph {

    rankdir = BT;

    node [shape = record];

    ziplist [label = &quot; zlbytes | zltail | zllen | &lt;new&gt; new | &lt;e1&gt; e1 | &lt;e2&gt; e2 | &lt;e3&gt; e3 | &lt;more&gt; ... | &lt;en&gt; eN | zlend &quot;];

    p [label = &quot;一直扩展下去……&quot;, shape = plaintext];

    p -&gt; ziplist:more;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-7aabda3e118e21556488da60d6198b29c5d7f554.png" alt="digraph {

    label = &quot;\n 图 7-13    连锁更新过程&quot;;

    rankdir = BT;

    node [shape = record];

    ziplist [label = &quot; zlbytes | zltail | zllen | &lt;new&gt; new | &lt;e1&gt; e1 | &lt;e2&gt; e2 | &lt;e3&gt; e3 | &lt;e4&gt; e4 | ... | &lt;eN&gt; eN | zlend &quot;];

    p [label = &quot;为 eN-1 扩展 eN 的 previous_entry_length 属性 \n 连锁更新到此结束&quot;, shape = plaintext];

    p -&gt; ziplist:eN;

}" />
</p>
<p>除了添加新节点可能会引发连锁更新之外，
删除节点也可能会引发连锁更新。</p>
<p>考虑图 7-14 所示的压缩列表，
如果 <code class="docutils literal"><span class="pre">e1</span></code> 至 <code class="docutils literal"><span class="pre">eN</span></code> 都是大小介于 <code class="docutils literal"><span class="pre">250</span></code> 字节至 <code class="docutils literal"><span class="pre">253</span></code> 字节的节点，
<code class="docutils literal"><span class="pre">big</span></code> 节点的长度大于等于 <code class="docutils literal"><span class="pre">254</span></code> 字节（需要 <code class="docutils literal"><span class="pre">5</span></code> 字节的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 来保存），
而 <code class="docutils literal"><span class="pre">small</span></code> 节点的长度小于 <code class="docutils literal"><span class="pre">254</span></code> 字节（只需要 <code class="docutils literal"><span class="pre">1</span></code> 字节的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 来保存），
那么当我们将 <code class="docutils literal"><span class="pre">small</span></code> 节点从压缩列表中删除之后，
为了让 <code class="docutils literal"><span class="pre">e1</span></code> 的 <code class="docutils literal"><span class="pre">previous_entry_length</span></code> 属性可以记录 <code class="docutils literal"><span class="pre">big</span></code> 节点的长度，
程序将扩展 <code class="docutils literal"><span class="pre">e1</span></code> 的空间，
并由此引发之后的连锁更新。</p>
<p class="graphviz">
<img src="../../_images/graphviz-e791bb78b6050d9103e63c12a3daef3a705a711d.png" alt="digraph {

    label = &quot;\n 图 7-14    另一种引起连锁更新的情况&quot;;

    rankdir = BT;

    node [shape = record];

    ziplist [label = &quot; zlbytes| zltail | zllen | big | &lt;small&gt; small | e1 | e2 | e3 | ... | eN | zlend &quot;];

    node [shape = plaintext];

    p [label = &quot;删去 small 节点将引发连锁更新&quot;];

    p -&gt; ziplist:small;

}" />
</p>
<p>因为连锁更新在最坏情况下需要对压缩列表执行 <code class="docutils literal"><span class="pre">N</span></code> 次空间重分配操作，
而每次空间重分配的最坏复杂度为 <span class="math">O(N)</span> ，
所以连锁更新的最坏复杂度为 <span class="math">O(N^2)</span> 。</p>
<p>要注意的是，
尽管连锁更新的复杂度较高，
但它真正造成性能问题的几率是很低的：</p>
<ul class="simple">
<li>首先，
压缩列表里要恰好有多个连续的、长度介于 <code class="docutils literal"><span class="pre">250</span></code> 字节至 <code class="docutils literal"><span class="pre">253</span></code> 字节之间的节点，
连锁更新才有可能被引发，
在实际中，
这种情况并不多见；</li>
<li>其次，
即使出现连锁更新，
但只要被更新的节点数量不多，
就不会对性能造成任何影响：
比如说，
对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
<p>因为以上原因，
<code class="docutils literal"><span class="pre">ziplistPush</span></code> 等命令的平均复杂度仅为 <span class="math">O(N)</span> ，
在实际中，
我们可以放心地使用这些函数，
而不必担心连锁更新会影响压缩列表的性能。</p>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisbookv1'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, 黄健宏（huangz）.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>