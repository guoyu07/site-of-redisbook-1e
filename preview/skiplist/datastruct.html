<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>跳跃表的实现 &mdash; Redis 设计与实现</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Redis 设计与实现" href="../../index.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>跳跃表的实现<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Redis 的跳跃表由 <code class="docutils literal"><span class="pre">redis.h/zskiplistNode</span></code> 和 <code class="docutils literal"><span class="pre">redis.h/zskiplist</span></code> 两个结构定义，
其中 <code class="docutils literal"><span class="pre">zskiplistNode</span></code> 结构用于表示跳跃表节点，
而 <code class="docutils literal"><span class="pre">zskiplist</span></code> 结构则用于保存跳跃表节点的相关信息，
比如节点的数量，
以及指向表头节点和表尾节点的指针，
等等。</p>
<p class="graphviz">
<img src="../../_images/graphviz-8fc5de396a5b52c3d0b1991a1e09558ad055dd86.png" alt="digraph {

    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 1.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 2.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 3.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    l:header -&gt; header;
    l:tail -&gt; C;

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back];

    label = &quot;\n 图 5-1    一个跳跃表&quot;;
}" />
</p>
<p>图 5-1 展示了一个跳跃表示例，
位于图片最左边的是 <code class="docutils literal"><span class="pre">zskiplist</span></code> 结构，
该结构包含以下属性：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">header</span></code> ：指向跳跃表的表头节点。</li>
<li><code class="docutils literal"><span class="pre">tail</span></code> ：指向跳跃表的表尾节点。</li>
<li><code class="docutils literal"><span class="pre">level</span></code> ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li><code class="docutils literal"><span class="pre">length</span></code> ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 <code class="docutils literal"><span class="pre">zskiplist</span></code> 结构右方的是四个 <code class="docutils literal"><span class="pre">zskiplistNode</span></code> 结构，
该结构包含以下属性：</p>
<ul class="simple">
<li>层（level）：节点中用 <code class="docutils literal"><span class="pre">L1</span></code> 、 <code class="docutils literal"><span class="pre">L2</span></code> 、 <code class="docutils literal"><span class="pre">L3</span></code> 等字样标记节点的各个层， <code class="docutils literal"><span class="pre">L1</span></code> 代表第一层， <code class="docutils literal"><span class="pre">L2</span></code> 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 <code class="docutils literal"><span class="pre">BW</span></code> 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 <code class="docutils literal"><span class="pre">1.0</span></code> 、 <code class="docutils literal"><span class="pre">2.0</span></code> 和 <code class="docutils literal"><span class="pre">3.0</span></code> 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 <code class="docutils literal"><span class="pre">o1</span></code> 、 <code class="docutils literal"><span class="pre">o2</span></code> 和 <code class="docutils literal"><span class="pre">o3</span></code> 是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的：
表头节点也有后退指针、分值和成员对象，
不过表头节点的这些属性都不会被用到，
所以图中省略了这些部分，
只显示了表头节点的各个层。</p>
<p>本节接下来的内容将对 <code class="docutils literal"><span class="pre">zskiplistNode</span></code> 和 <code class="docutils literal"><span class="pre">zskiplist</span></code> 两个结构进行更详细的介绍。</p>
<div class="section" id="id2">
<h2>跳跃表节点<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>跳跃表节点的实现由 <code class="docutils literal"><span class="pre">redis.h/zskiplistNode</span></code> 结构定义：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>

    <span class="c1">// 后退指针</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>

    <span class="c1">// 分值</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>

    <span class="c1">// 成员对象</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

    <span class="c1">// 层</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>

        <span class="c1">// 前进指针</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>

        <span class="c1">// 跨度</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">span</span><span class="p">;</span>

    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>

<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="id3">
<h3>层<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>跳跃表节点的 <code class="docutils literal"><span class="pre">level</span></code> 数组可以包含多个元素，
每个元素都包含一个指向其他节点的指针，
程序可以通过这些层来加快访问其他节点的速度，
一般来说，
层的数量越多，
访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候，
程序都根据幂次定律
（<a class="reference external" href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小）
随机生成一个介于 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">32</span></code> 之间的值作为 <code class="docutils literal"><span class="pre">level</span></code> 数组的大小，
这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 <code class="docutils literal"><span class="pre">1</span></code> 层、 <code class="docutils literal"><span class="pre">3</span></code> 层和 <code class="docutils literal"><span class="pre">5</span></code> 层的节点，
因为 C 语言的数组索引总是从 <code class="docutils literal"><span class="pre">0</span></code> 开始的，
所以节点的第一层是 <code class="docutils literal"><span class="pre">level[0]</span></code> ，
而第二层是 <code class="docutils literal"><span class="pre">level[1]</span></code> ，
以此类推。</p>
<p class="graphviz">
<img src="../../_images/graphviz-1983e65fd518acd94a59d64f018bfa4d83655cb6.png" alt="digraph {

    label = &quot;\n 图 5-2    带有不同层高的节点&quot;;

    rankdir = LR;

    //

    node [shape = record];

    n1 [label = &quot; zskiplistNode | level[0] | backward | score | obj &quot;];
    n2 [label = &quot; zskiplistNode | level[2] | level[1] | level[0] | backward | score | obj &quot;];
    n3 [label = &quot; zskiplistNode | level[4] | level[3] | level[2] | level[1] | level[0] | backward | score | obj &quot;];

    //

    edge [style = invis];

    n1 -&gt; n2 -&gt; n3;
}" />
</p>
</div>
<div class="section" id="id4">
<h3>前进指针<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>每个层都有一个指向表尾方向的前进指针（<code class="docutils literal"><span class="pre">level[i].forward</span></code> 属性），
用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向，
遍历跳跃表中所有节点的路径：</p>
<ol class="arabic simple">
<li>迭代程序首先访问跳跃表的第一个节点（表头），
然后从第四层的前进指针移动到表中的第二个节点。</li>
<li>在第二个节点时，
程序沿着第二层的前进指针移动到表中的第三个节点。</li>
<li>在第三个节点时，
程序同样沿着第二层的前进指针移动到表中的第四个节点。</li>
<li>当程序再次沿着第四个节点的前进指针移动时，
它碰到一个 <code class="docutils literal"><span class="pre">NULL</span></code> ，
程序知道这时已经到达了跳跃表的表尾，
于是结束这次遍历。</li>
</ol>
<p class="graphviz">
<img src="../../_images/graphviz-e252c0a9575f171b9721162311df23889699cac9.png" alt="digraph {


    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 1.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 2.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 3.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    l:header -&gt; header [style = dashed];
    l:tail -&gt; C;

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;, style = dashed];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;, style = dashed];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;, style = dashed];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;, style = dashed];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back];


    label = &quot;\n 图 5-3    遍历整个跳跃表&quot;;
}" />
</p>
</div>
<div class="section" id="id5">
<h3>跨度<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>层的跨度（<code class="docutils literal"><span class="pre">level[i].span</span></code> 属性）用于记录两个节点之间的距离：</p>
<ul class="simple">
<li>两个节点之间的跨度越大，
它们相距得就越远。</li>
<li>指向 <code class="docutils literal"><span class="pre">NULL</span></code> 的所有前进指针的跨度都为 <code class="docutils literal"><span class="pre">0</span></code> ，
因为它们没有连向任何节点。</li>
</ul>
<p>初看上去，
很容易以为跨度和遍历操作有关，
但实际上并不是这样 ——
遍历操作只使用前进指针就可以完成了，
跨度实际上是用来计算排位（rank）的：
在查找某个节点的过程中，
将沿途访问过的所有层的跨度累计起来，
得到的结果就是目标节点在跳跃表中的排位。</p>
<p>举个例子，
图 5-4 用虚线标记了在跳跃表中查找分值为 <code class="docutils literal"><span class="pre">3.0</span></code> 、
成员对象为 <code class="docutils literal"><span class="pre">o3</span></code> 的节点时，
沿途经历的层：
查找的过程只经过了一个层，
并且层的跨度为 <code class="docutils literal"><span class="pre">3</span></code> ，
所以目标节点在跳跃表中的排位为 <code class="docutils literal"><span class="pre">3</span></code> 。</p>
<p class="graphviz">
<img src="../../_images/graphviz-b5f725abb2be0255dce02cc1b9b404595edff320.png" alt="digraph {

    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 1.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 2.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 3.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    l:header -&gt; header [style = dashed];
    l:tail -&gt; C;

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;, style = dashed];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back];

    label = &quot;\n 图 5-4    计算节点的排位&quot;;

}" />
</p>
<p>再举个例子，
图 5-5 用虚线标记了在跳跃表中查找分值为 <code class="docutils literal"><span class="pre">2.0</span></code> 、
成员对象为 <code class="docutils literal"><span class="pre">o2</span></code> 的节点时，
沿途经历的层：
在查找节点的过程中，
程序经过了两个跨度为 <code class="docutils literal"><span class="pre">1</span></code> 的节点，
因此可以计算出，
目标节点在跳跃表中的排位为 2 。</p>
<p class="graphviz">
<img src="../../_images/graphviz-35aacc5673063633ae0decd516137022c304ac1b.png" alt="digraph {

    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 1.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 2.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 3.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    l:header -&gt; header [style = dashed];
    l:tail -&gt; C;

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;, style = dashed];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;, style = dashed];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back];

    label = &quot;\n 图 5-5    另一个计算节点排位的例子&quot;;
}" />
</p>
</div>
<div class="section" id="id6">
<h3>后退指针<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>节点的后退指针（<code class="docutils literal"><span class="pre">backward</span></code> 属性）用于从表尾向表头方向访问节点：
跟可以一次跳过多个节点的前进指针不同，
因为每个节点只有一个后退指针，
所以每次只能后退至前一个节点。</p>
<p>图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点：
程序首先通过跳跃表的 <code class="docutils literal"><span class="pre">tail</span></code> 指针访问表尾节点，
然后通过后退指针访问倒数第二个节点，
之后再沿着后退指针访问倒数第三个节点，
再之后遇到指向 <code class="docutils literal"><span class="pre">NULL</span></code> 的后退指针，
于是访问结束。</p>
<p class="graphviz">
<img src="../../_images/graphviz-35029fe9a9dbed7001f6fee063c0b376bca6e54d.png" alt="digraph {

    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 1.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 2.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 3.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    l:header -&gt; header;
    l:tail -&gt; C [style = dashed];

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back, style = dashed];

    label = &quot;\n 图 5-6    从表尾向表头方向遍历跳跃表&quot;;
}" />
</p>
</div>
<div class="section" id="id7">
<h3>分值和成员<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>节点的分值（<code class="docutils literal"><span class="pre">score</span></code> 属性）是一个 <code class="docutils literal"><span class="pre">double</span></code> 类型的浮点数，
跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（<code class="docutils literal"><span class="pre">obj</span></code> 属性）是一个指针，
它指向一个字符串对象，
而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中，
各个节点保存的成员对象必须是唯一的，
但是多个节点保存的分值却可以是相同的：
分值相同的节点将按照成员对象在字典序中的大小来进行排序，
成员对象较小的节点会排在前面（靠近表头的方向），
而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<p>举个例子，
在图 5-7 所示的跳跃表中，
三个跳跃表节点都保存了相同的分值 <code class="docutils literal"><span class="pre">10086.0</span></code> ，
但保存成员对象 <code class="docutils literal"><span class="pre">o1</span></code> 的节点却排在保存成员对象 <code class="docutils literal"><span class="pre">o2</span></code> 和 <code class="docutils literal"><span class="pre">o3</span></code> 的节点之前，
而保存成员对象 <code class="docutils literal"><span class="pre">o2</span></code> 的节点又排在保存成员对象 <code class="docutils literal"><span class="pre">o3</span></code> 的节点之前，
由此可见，
<code class="docutils literal"><span class="pre">o1</span></code> 、 <code class="docutils literal"><span class="pre">o2</span></code> 、 <code class="docutils literal"><span class="pre">o3</span></code> 三个成员对象在字典中的排序为 <code class="docutils literal"><span class="pre">o1</span> <span class="pre">&lt;=</span> <span class="pre">o2</span> <span class="pre">&lt;=</span> <span class="pre">o3</span></code> 。</p>
<p class="graphviz">
<img src="../../_images/graphviz-2eca5f315d20b6ceb145dbce294dc00f979605f2.png" alt="digraph {

    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 10086.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 10086.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 10086.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    l:header -&gt; header;
    l:tail -&gt; C;

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back];

    label = &quot;\n 图 5-7    三个带有相同分值的跳跃表节点&quot;;
}" />
</p>
</div>
</div>
<div class="section" id="id8">
<h2>跳跃表<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表，
如图 5-8 所示。</p>
<p class="graphviz">
<img src="../../_images/graphviz-f052ef64363e3e6f72df13857a3c0ca079eee28f.png" alt="digraph {

    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    //l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 1.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 2.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 3.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    //l:header -&gt; header;
    //l:tail -&gt; C;

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back];

    label = &quot;\n 图 5-8    由多个跳跃表节点组成的跳跃表&quot;;
}" />
</p>
<p>但通过使用一个 <code class="docutils literal"><span class="pre">zskiplist</span></code> 结构来持有这些节点，
程序可以更方便地对整个跳跃表进行处理，
比如快速访问跳跃表的表头节点和表尾节点，
又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息，
如图 5-9 所示。</p>
<p class="graphviz">
<img src="../../_images/graphviz-59432127803598137980d030e8e529c5b068bebb.png" alt="digraph {

    rankdir = LR;

    node [shape = record, width = &quot;0.5&quot;];

    //

    l [label = &quot; &lt;header&gt; header | &lt;tail&gt; tail | level \n 5 | length \n 3 &quot;];

    subgraph cluster_nodes {

        style = invisible;

        header [label = &quot; &lt;l32&gt; L32 | ... | &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 &quot;];

        bw_null [label = &quot;NULL&quot;, shape = plaintext];

        level_null [label = &quot;NULL&quot;, shape = plaintext];

        A [label = &quot; &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 1.0 | o1 &quot;];

        B [label = &quot; &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 2.0 | o2 &quot;];

        C [label = &quot; &lt;l5&gt; L5 | &lt;l4&gt; L4 | &lt;l3&gt; L3 | &lt;l2&gt; L2 | &lt;l1&gt; L1 | &lt;backward&gt; BW | 3.0 | o3 &quot;];

    }

    subgraph cluster_nulls {

        style = invisible;

        n1 [label = &quot;NULL&quot;, shape = plaintext];
        n2 [label = &quot;NULL&quot;, shape = plaintext];
        n3 [label = &quot;NULL&quot;, shape = plaintext];
        n4 [label = &quot;NULL&quot;, shape = plaintext];
        n5 [label = &quot;NULL&quot;, shape = plaintext];

    }

    //

    l:header -&gt; header;
    l:tail -&gt; C;

    header:l32 -&gt; level_null [label = &quot;0&quot;];
    header:l5 -&gt; C:l5 [label = &quot;3&quot;];
    header:l4 -&gt; A:l4 [label = &quot;1&quot;];
    header:l3 -&gt; A:l3 [label = &quot;1&quot;];
    header:l2 -&gt; A:l2 [label = &quot;1&quot;];
    header:l1 -&gt; A:l1 [label = &quot;1&quot;];

    A:l4 -&gt; C:l4 [label = &quot;2&quot;];
    A:l3 -&gt; C:l3 [label = &quot;2&quot;];
    A:l2 -&gt; B:l2 [label = &quot;1&quot;];
    A:l1 -&gt; B:l1 [label = &quot;1&quot;];

    B:l2 -&gt; C:l2 [label = &quot;1&quot;];
    B:l1 -&gt; C:l1 [label = &quot;1&quot;];

    C:l5 -&gt; n5 [label = &quot;0&quot;];
    C:l4 -&gt; n4 [label = &quot;0&quot;];
    C:l3 -&gt; n3 [label = &quot;0&quot;];
    C:l2 -&gt; n2 [label = &quot;0&quot;];
    C:l1 -&gt; n1 [label = &quot;0&quot;];

    bw_null -&gt; A:backward -&gt; B:backward -&gt; C:backward [dir = back];

    label = &quot;\n 图 5-9    带有 zskiplist 结构的跳跃表&quot;;
}" />
</p>
<p><code class="docutils literal"><span class="pre">zskiplist</span></code> 结构的定义如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>

    <span class="c1">// 表头节点和表尾节点</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>

    <span class="c1">// 表中节点的数量</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>

    <span class="c1">// 表中层数最大的节点的层数</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

<span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">header</span></code> 和 <code class="docutils literal"><span class="pre">tail</span></code> 指针分别指向跳跃表的表头和表尾节点，
通过这两个指针，
程序定位表头节点和表尾节点的复杂度为 <span class="math">O(1)</span> 。</p>
<p>通过使用 <code class="docutils literal"><span class="pre">length</span></code> 属性来记录节点的数量，
程序可以在 <span class="math">O(1)</span> 复杂度内返回跳跃表的长度。</p>
<p><code class="docutils literal"><span class="pre">level</span></code> 属性则用于在 <span class="math">O(1)</span> 复杂度内获取跳跃表中层高最大的那个节点的层数量，
注意表头节点的层高并不计算在内。</p>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisbookv1'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, 黄健宏（huangz）.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>