<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>创建并修改 Lua 环境 &mdash; Redis 设计与实现</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Redis 设计与实现" href="../../index.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="lua">
<h1>创建并修改 Lua 环境<a class="headerlink" href="#lua" title="Permalink to this headline">¶</a></h1>
<p>为了在 Redis 服务器中执行 Lua 脚本，
Redis 在服务器内嵌了一个 Lua 环境（environment），
并对这个 Lua 环境进行了一系列修改，
从而确保这个 Lua 环境可以满足 Redis 服务器的需要。</p>
<p>Redis 服务器创建并修改 Lua 环境的整个过程由以下步骤组成：</p>
<ol class="arabic simple">
<li>创建一个基础的 Lua 环境，
之后的所有修改都是针对这个环境进行的。</li>
<li>载入多个函数库到 Lua 环境里面，
让 Lua 脚本可以使用这些函数库来进行数据操作。</li>
<li>创建全局表格 <code class="docutils literal"><span class="pre">redis</span></code> ，
这个表格包含了对 Redis 进行操作的函数，
比如用于在 Lua 脚本中执行 Redis 命令的 <code class="docutils literal"><span class="pre">redis.call</span></code> 函数。</li>
<li>使用 Redis 自制的随机函数来替换 Lua 原有的带有副作用的随机函数，
从而避免在脚本中引入副作用。</li>
<li>创建排序辅助函数，
Lua 环境使用这个辅佐函数来对一部分 Redis 命令的结果进行排序，
从而消除这些命令的不确定性。</li>
<li>创建 <code class="docutils literal"><span class="pre">redis.pcall</span></code> 函数的错误报告辅助函数，
这个函数可以提供更详细的出错信息。</li>
<li>对 Lua 环境里面的全局环境进行保护，
防止用户在执行 Lua 脚本的过程中，
将额外的全局变量添加到了 Lua 环境里面。</li>
<li>将完成修改的 Lua 环境保存到服务器状态的 <code class="docutils literal"><span class="pre">lua</span></code> 属性里面，
等待执行服务器传来的 Lua 脚本。</li>
</ol>
<p>接下来的各个小节将分别介绍这些步骤。</p>
<div class="section" id="id1">
<h2>创建 Lua 环境<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>在最开始的这一步，
服务器首先调用 Lua 的 C API 函数 <code class="docutils literal"><span class="pre">lua_open</span></code> ，
创建一个新的 Lua 环境。</p>
<p>因为 lua_open 函数创建的只是一个基本的 Lua 环境，
为了让这个 Lua 环境可以满足 Redis 的操作要求，
接下来服务器将对这个 Lua 环境进行一系列修改。</p>
</div>
<div class="section" id="id2">
<h2>载入函数库<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Redis 修改 Lua 环境的第一步，
就是将以下函数库载入到 Lua 环境里面：</p>
<ul class="simple">
<li>基础库（base library）：
这个库包含 Lua 的核心（core）函数，
比如 <code class="docutils literal"><span class="pre">assert</span></code> 、 <code class="docutils literal"><span class="pre">error</span></code> 、 <code class="docutils literal"><span class="pre">pairs</span></code> 、 <code class="docutils literal"><span class="pre">tostring</span></code> 、 <code class="docutils literal"><span class="pre">pcall</span></code> ，
等等。
另外，
为了防止用户从外部文件中引入不安全的代码，
库中的 <code class="docutils literal"><span class="pre">loadfile</span></code> 函数会被删除。</li>
<li>表格库（table library）：
这个库包含用于处理表格的通用函数，
比如 <code class="docutils literal"><span class="pre">table.concat</span></code> 、 <code class="docutils literal"><span class="pre">table.insert</span></code> 、 <code class="docutils literal"><span class="pre">table.remove</span></code> 、 <code class="docutils literal"><span class="pre">table.sort</span></code> ，
等等。</li>
<li>字符串库（string library）：
这个库包含用于处理字符串的通用函数，
比如用于对字符串进行查找的 <code class="docutils literal"><span class="pre">string.find</span></code> 函数，
对字符串进行格式化的 <code class="docutils literal"><span class="pre">string.format</span></code> 函数，
查看字符串长度的 <code class="docutils literal"><span class="pre">string.len</span></code> 函数，
对字符串进行翻转的 <code class="docutils literal"><span class="pre">string.reverse</span></code> 函数，
等等。</li>
<li>数学库（math library）：
这个库是标准 C 语言数学库的接口，
它包括计算绝对值的 <code class="docutils literal"><span class="pre">math.abs</span></code> 函数，
返回多个数中的最大值和最小值的 <code class="docutils literal"><span class="pre">math.max</span></code> 函数和 <code class="docutils literal"><span class="pre">math.min</span></code> 函数，
计算二次方根的 <code class="docutils literal"><span class="pre">math.sqrt</span></code> 函数，
计算对数的 <code class="docutils literal"><span class="pre">math.log</span></code> 函数，
等等。</li>
<li>调试库（debug library）：
这个库提供了对程序进行调试所需的函数，
比如对程序设置钩子和取得钩子的 <code class="docutils literal"><span class="pre">debug.sethook</span></code> 函数和 <code class="docutils literal"><span class="pre">debug.gethook</span></code> 函数，
返回给定函数相关信息的 <code class="docutils literal"><span class="pre">debug.getinfo</span></code> 函数，
为对象设置元数据的 <code class="docutils literal"><span class="pre">debug.setmetatable</span></code> 函数，
获取对象元数据的 <code class="docutils literal"><span class="pre">debug.getmetatable</span></code> 函数，
等等。</li>
<li>Lua CJSON 库（<a class="reference external" href="http://www.kyne.com.au/~mark/software/lua-cjson.php">http://www.kyne.com.au/~mark/software/lua-cjson.php</a>）：
这个库用于处理 UTF-8 编码的 JSON 格式，
其中 <code class="docutils literal"><span class="pre">cjson.decode</span></code> 函数将一个 JSON 格式的字符串转换为一个 Lua 值，
而 <code class="docutils literal"><span class="pre">cjson.encode</span></code> 函数将一个 Lua 值序列化为 JSON 格式的字符串。</li>
<li>Struct 库（<a class="reference external" href="http://www.inf.puc-rio.br/~roberto/struct/">http://www.inf.puc-rio.br/~roberto/struct/</a>）：
这个库用于在 Lua 值和 C 结构（struct）之间进行转换，
函数 <code class="docutils literal"><span class="pre">struct.pack</span></code> 将多个 Lua 值打包成一个类结构（struct-like）字符串，
而函数 <code class="docutils literal"><span class="pre">struct.unpack</span></code> 则从一个类结构字符串中解包出多个 Lua 值。</li>
<li>Lua cmsgpack 库（<a class="reference external" href="https://github.com/antirez/lua-cmsgpack">https://github.com/antirez/lua-cmsgpack</a>）：
这个库用于处理 MessagePack 格式的数据，
其中 <code class="docutils literal"><span class="pre">cmsgpack.pack</span></code> 函数将 Lua 值转换为 MessagePack 数据，
而 <code class="docutils literal"><span class="pre">cmsgpack.unpack</span></code> 函数则将 MessagePack 数据转换为 Lua 值。</li>
</ul>
<p>通过使用这些功能强大的函数库，
Lua 脚本可以直接对执行 Redis 命令获得的数据进行复杂的操作。</p>
</div>
<div class="section" id="redis">
<h2>创建 <code class="docutils literal"><span class="pre">redis</span></code> 全局表格<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h2>
<p>在这一步，
服务器将在 Lua 环境中创建一个 <code class="docutils literal"><span class="pre">redis</span></code> 表格（table），
并将它设为全局变量。</p>
<p>这个 <code class="docutils literal"><span class="pre">redis</span></code> 表格包含以下函数：</p>
<ul class="simple">
<li>用于执行 Redis 命令的 <code class="docutils literal"><span class="pre">redis.call</span></code> 和 <code class="docutils literal"><span class="pre">redis.pcall</span></code> 函数。</li>
<li>用于记录 Redis 日志（log）的 <code class="docutils literal"><span class="pre">redis.log</span></code> 函数，
以及相应的日志级别（level）常量：
<code class="docutils literal"><span class="pre">redis.LOG_DEBUG</span></code> ，
<code class="docutils literal"><span class="pre">redis.LOG_VERBOSE</span></code> ，
<code class="docutils literal"><span class="pre">redis.LOG_NOTICE</span></code> ，
以及 <code class="docutils literal"><span class="pre">redis.LOG_WARNING</span></code> 。</li>
<li>用于计算 SHA1 校验和的 <code class="docutils literal"><span class="pre">redis.sha1hex</span></code> 函数。</li>
<li>用于返回错误信息的 <code class="docutils literal"><span class="pre">redis.error_reply</span></code> 函数和 <code class="docutils literal"><span class="pre">redis.status_reply</span></code> 函数。</li>
</ul>
<p>在这些函数里面，
最常用也最重要的要数 <code class="docutils literal"><span class="pre">redis.call</span></code> 函数和 <code class="docutils literal"><span class="pre">redis.pcall</span></code> 函数 ——
通过这两个函数，
用户可以直接在 Lua 脚本中执行 Redis 命令：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">EVAL</span> <span class="s">&quot;return redis.call(&#39;PING&#39;)&quot;</span> <span class="mi">0</span>
<span class="n">PONG</span>
</pre></div>
</div>
</div>
<div class="section" id="redis-lua">
<h2>使用 Redis 自制的随机函数来替换 Lua 原有的随机函数<a class="headerlink" href="#redis-lua" title="Permalink to this headline">¶</a></h2>
<p>为了保证相同的脚本可以在不同的机器上产生相同的结果，
Redis 要求所有传入服务器的 Lua 脚本，
以及 Lua 环境中的所有函数，
都必须是无副作用（<a class="reference external" href="http://en.wikipedia.org/wiki/Side_effect_(computer_science)">side effect</a>）的纯函数（<a class="reference external" href="http://en.wikipedia.org/wiki/Pure_function">pure function</a>）。</p>
<p>但是，
在之前载入到 Lua 环境的 <code class="docutils literal"><span class="pre">math</span></code> 函数库中，
用于生成随机数的 <code class="docutils literal"><span class="pre">math.random</span></code> 函数和 <code class="docutils literal"><span class="pre">math.randomseed</span></code> 函数都是带有副作用的，
它们不符合 Redis 对 Lua 环境的无副作用要求。</p>
<p>因为这个原因，
Redis 使用自制的函数替换了 <code class="docutils literal"><span class="pre">math</span></code> 库中原有的 <code class="docutils literal"><span class="pre">math.random</span></code> 函数和 <code class="docutils literal"><span class="pre">math.randomseed</span></code> 函数，
替换之后的两个函数有以下特征：</p>
<ul class="simple">
<li>对于相同的 seed 来说，
<code class="docutils literal"><span class="pre">math.random</span></code> 总产生相同的随机数序列，
这个函数是一个纯函数。</li>
<li>除非在脚本中使用 <code class="docutils literal"><span class="pre">math.randomseed</span></code> 显式地修改 seed ，
否则每次运行脚本时，
Lua 环境都使用固定的 <code class="docutils literal"><span class="pre">math.randomseed(0)</span></code> 语句来初始化 seed 。</li>
</ul>
<p>比如说，
使用以下脚本，
我们可以打印 seed 值为 <code class="docutils literal"><span class="pre">0</span></code> 时，
<code class="docutils literal"><span class="pre">math.random</span></code> 对于输入 <code class="docutils literal"><span class="pre">10</span></code> 至 <code class="docutils literal"><span class="pre">1</span></code> 所产生的随机序列：</p>
<p>无论执行这个脚本多少次，
产生的值都是相同的：</p>
<div class="highlight-c"><div class="highlight"><pre>$ redis-cli --eval random-with-default-seed.lua
1) (integer) 1
2) (integer) 2
3) (integer) 2
4) (integer) 3
5) (integer) 4
6) (integer) 4
7) (integer) 7
8) (integer) 1
9) (integer) 7
10) (integer) 2
</pre></div>
</div>
<p>但是，
如果我们在另一个脚本里面，
调用 <code class="docutils literal"><span class="pre">math.randomseed</span></code> 将 seed 修改为 <code class="docutils literal"><span class="pre">10086</span></code> ：</p>
<p>那么这个脚本生成的随机数序列将和使用默认 seed 值 <code class="docutils literal"><span class="pre">0</span></code> 时生成的随机序列不同：</p>
<div class="highlight-c"><div class="highlight"><pre>$ redis-cli --eval random-with-new-seed.lua
1) (integer) 1
2) (integer) 1
3) (integer) 2
4) (integer) 1
5) (integer) 1
6) (integer) 3
7) (integer) 1
8) (integer) 1
9) (integer) 3
10) (integer) 1
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>创建排序辅助函数<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>上一个小节说到，
为了防止带有副作用的函数令脚本产生不一致的数据，
Redis 对 <code class="docutils literal"><span class="pre">math</span></code> 库的 <code class="docutils literal"><span class="pre">math.random</span></code> 函数和 <code class="docutils literal"><span class="pre">math.randomseed</span></code> 函数进行了替换。</p>
<p>对于 Lua 脚本来说，
另一个可能产生不一致数据的地方是那些带有不确定性质的命令。</p>
<p>比如对于一个集合键来说，
因为集合元素的排列是无序的，
所以即使两个集合的元素完全相同，
它们的输出结果也可能并不相同。</p>
<p>考虑下面这个集合例子：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">fruit</span> <span class="n">apple</span> <span class="n">banana</span> <span class="n">cherry</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">3</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">fruit</span>
<span class="mi">1</span><span class="p">)</span> <span class="s">&quot;cherry&quot;</span>
<span class="mi">2</span><span class="p">)</span> <span class="s">&quot;banana&quot;</span>
<span class="mi">3</span><span class="p">)</span> <span class="s">&quot;apple&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">another</span><span class="o">-</span><span class="n">fruit</span> <span class="n">cherry</span> <span class="n">banana</span> <span class="n">apple</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">3</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">another</span><span class="o">-</span><span class="n">fruit</span>
<span class="mi">1</span><span class="p">)</span> <span class="s">&quot;apple&quot;</span>
<span class="mi">2</span><span class="p">)</span> <span class="s">&quot;banana&quot;</span>
<span class="mi">3</span><span class="p">)</span> <span class="s">&quot;cherry&quot;</span>
</pre></div>
</div>
<p>这个例子中的 <code class="docutils literal"><span class="pre">fruit</span></code> 集合和 <code class="docutils literal"><span class="pre">another-fruit</span></code> 集合包含的元素是完全相同的，
只是因为集合添加元素的顺序不同，
<span class="xref std std-ref">SMEMBERS</span> 命令的输出就产生了不同的结果。</p>
<p>Redis 将 <span class="xref std std-ref">SMEMBERS</span> 这种在相同数据集上可能会产生不同输出的命令称为“带有不确定性的命令”，
这些命令包括：</p>
<ul class="simple">
<li><span class="xref std std-ref">SINTER</span></li>
<li><span class="xref std std-ref">SUNION</span></li>
<li><span class="xref std std-ref">SDIFF</span></li>
<li><span class="xref std std-ref">SMEMBERS</span></li>
<li><span class="xref std std-ref">HKEYS</span></li>
<li><span class="xref std std-ref">HVALS</span></li>
<li><span class="xref std std-ref">KEYS</span></li>
</ul>
<p>为了消除这些命令带来的不确定性，
服务器会为 Lua 环境创建一个排序辅助函数 <code class="docutils literal"><span class="pre">__redis__compare_helper</span></code> ，
当 Lua 脚本执行完一个带有不确定性的命令之后，
程序会使用 <code class="docutils literal"><span class="pre">__redis__compare_helper</span></code> 作为对比函数，
自动调用 <code class="docutils literal"><span class="pre">table.sort</span></code> 函数对命令的返回值做一次排序，
以此来保证相同的数据集总是产生相同的输出。</p>
<p>举个例子，
如果我们在 Lua 脚本中对 <code class="docutils literal"><span class="pre">fruit</span></code> 集合和 <code class="docutils literal"><span class="pre">another-fruit</span></code> 集合执行 <span class="xref std std-ref">SMEMBERS</span> 命令，
那么两个脚本将得出相同的结果 ——
因为脚本已经对 <span class="xref std std-ref">SMEMBERS</span> 命令的输出进行过排序了：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">EVAL</span> <span class="s">&quot;return redis.call(&#39;SMEMBERS&#39;, KEYS[1])&quot;</span> <span class="mi">1</span> <span class="n">fruit</span>
<span class="mi">1</span><span class="p">)</span> <span class="s">&quot;apple&quot;</span>
<span class="mi">2</span><span class="p">)</span> <span class="s">&quot;banana&quot;</span>
<span class="mi">3</span><span class="p">)</span> <span class="s">&quot;cherry&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EVAL</span> <span class="s">&quot;return redis.call(&#39;SMEMBERS&#39;, KEYS[1])&quot;</span> <span class="mi">1</span> <span class="n">another</span><span class="o">-</span><span class="n">fruit</span>
<span class="mi">1</span><span class="p">)</span> <span class="s">&quot;apple&quot;</span>
<span class="mi">2</span><span class="p">)</span> <span class="s">&quot;banana&quot;</span>
<span class="mi">3</span><span class="p">)</span> <span class="s">&quot;cherry&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="redis-pcall">
<h2>创建 <code class="docutils literal"><span class="pre">redis.pcall</span></code> 函数的错误报告辅助函数<a class="headerlink" href="#redis-pcall" title="Permalink to this headline">¶</a></h2>
<p>在这一步，
服务器将为 Lua 环境创建一个名为 <code class="docutils literal"><span class="pre">__redis__err__handler</span></code> 的错误处理函数，
当脚本调用 <code class="docutils literal"><span class="pre">redis.pcall</span></code> 函数执行 Redis 命令，
并且被执行的命令出现错误时，
<code class="docutils literal"><span class="pre">__redis__err__handler</span></code> 就会打印出错代码的来源和发生错误的行数，
为程序的调试提供方便。</p>
<p>举个例子，
如果客户端要求服务器执行以下 Lua 脚本：</p>
<p>那么服务器将向客户端返回一个错误：</p>
<div class="highlight-c"><div class="highlight"><pre>$ redis-cli --eval wrong-command.lua
(error) @user_script: 4: Unknown Redis command called from Lua script
</pre></div>
</div>
<p>其中 <code class="docutils literal"><span class="pre">&#64;user_script</span></code> 说明这是一个用户定义的函数，
而之后的 <code class="docutils literal"><span class="pre">4</span></code> 则说明出错的代码位于 Lua 脚本的第四行。</p>
</div>
<div class="section" id="id4">
<h2>保护 Lua 的全局环境<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>在这一步，
服务器将对 Lua 环境中的全局环境进行保护，
确保传入服务器的脚本不会因为忘记使用 <code class="docutils literal"><span class="pre">local</span></code> 关键字而将额外的全局变量添加到了 Lua 环境里面。</p>
<p>因为全局变量保护的原因，
当一个脚本试图创建一个全局变量时，
服务器将报告一个错误：</p>
<div class="highlight-c"><div class="highlight"><pre>redis&gt; EVAL &quot;x = 10&quot; 0
(error) ERR Error running script
(call to f_df1ad3745c2d2f078f0f41377a92bb6f8ac79af0):
@enable_strict_lua:7: user_script:1:
Script attempted to create global variable &#39;x&#39;
</pre></div>
</div>
<p>除此之外，
试图获取一个不存在的全局变量也会引发一个错误：</p>
<div class="highlight-c"><div class="highlight"><pre>redis&gt; EVAL &quot;return x&quot; 0
(error) ERR Error running script
(call to f_03c387736bb5cc009ff35151572cee04677aa374):
@enable_strict_lua:14: user_script:1:
Script attempted to access unexisting global variable &#39;x&#39;
</pre></div>
</div>
<p>不过 Redis 并未禁止用户修改已存在的全局变量，
所以在执行 Lua 脚本的时候，
必须非常小心，
以免错误地修改了已存在的全局变量：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">EVAL</span> <span class="s">&quot;redis = 10086; return redis&quot;</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">10086</span>
</pre></div>
</div>
</div>
<div class="section" id="lua-lua">
<h2>将 Lua 环境保存到服务器状态的 <code class="docutils literal"><span class="pre">lua</span></code> 属性里面<a class="headerlink" href="#lua-lua" title="Permalink to this headline">¶</a></h2>
<p>经过以上的一系列修改，
Redis 服务器对 Lua 环境的修改工作到此就结束了，
在最后的这一步，
服务器会将 Lua 环境和服务器状态的 <code class="docutils literal"><span class="pre">lua</span></code> 属性关联起来，
如图 IMAGE_REDIS_SERVER_LUA 所示。</p>
<p class="graphviz">
<img src="../../_images/graphviz-35d9dfe00f3e5f324473febdda92a515acc3ca08.png" alt="digraph {

    label = &quot;\n图 IMAGE_REDIS_SERVER_LUA    服务器状态中的 Lua 环境&quot;;

    rankdir = LR;

    node [shape = record];

    server [label = &quot;redisServer | ... | &lt;lua&gt; lua | ...&quot;, width = 2.0, height = 2.0];

    lua [label = &quot;Lua 环境&quot;, shape = circle];

    server:lua -&gt; lua;

}" />
</p>
<p>因为 Redis 使用串行化的方式来执行 Redis 命令，
所以在任何特定时间里，
最多都只会有一个脚本能够被放进 Lua 环境里面运行，
因此，
整个 Redis 服务器只需要创建一个 Lua 环境即可。</p>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisbookv1'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, 黄健宏（huangz）.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>