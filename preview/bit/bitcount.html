<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>BITCOUNT 命令的实现 &mdash; Redis 设计与实现</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Redis 设计与实现" href="../../index.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="bitcount">
<h1>BITCOUNT 命令的实现<a class="headerlink" href="#bitcount" title="Permalink to this headline">¶</a></h1>
<p><em class="xref std std-ref">BITCOUNT</em> 命令用于统计给定位数组中，
值为 <code class="docutils literal"><span class="pre">1</span></code> 的二进制位的数量。</p>
<p>举个例子，
对于图 22-15 所示的位数组来说，
<em class="xref std std-ref">BITCOUNT</em> 命令将返回 <code class="docutils literal"><span class="pre">4</span></code> 。</p>
<p class="graphviz">
<img src="../../_images/graphviz-ef3e6acfd43455df05ffbdba7914e7f47f06482f.png" alt="digraph {

    label = &quot;\n 图 22-15    BITCOUNT 命令示例一&quot;;

    //

    rankdir = LR;

    buf [label = &quot; { &lt;buf0&gt; buf[0] | 1 | 0 | 1 | &lt;idx3&gt; 1 | 0 | 0 | 1 | 0 } | { buf[1] （空字符） } &quot;, shape = record];

    //

    edge [style = dashed];

}" />
</p>
<p>而对于图 22-16 所示的位数组来说，
<em class="xref std std-ref">BITCOUNT</em> 命令将返回 <code class="docutils literal"><span class="pre">12</span></code> 。</p>
<p class="graphviz">
<img src="../../_images/graphviz-8cb733b1a46bd616d2c4b0e727f90b174899da48.png" alt="digraph {

    label = &quot;\n 图 22-16    BITCOUNT 命令示例二&quot;;

    rankdir = LR;

    //

    node [shape = record];

    buf [label = &quot; { buf[0] | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 } | { &lt;buf1&gt; buf[1] | 1 | 1 | &lt;bit&gt; 0 | 0 | 0 | 0 | 1 | 1 } | { buf[2] | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 } | { buf[3] （空字符） } &quot;];

    //

}" />
</p>
<p><em class="xref std std-ref">BITCOUNT</em> 命令要做的工作初看上去并不复杂，
但实际上要高效地实现这个命令并不容易，
需要用到一些精巧的算法。</p>
<p>接下来的几个小节将对 <em class="xref std std-ref">BITCOUNT</em> 命令可能使用的几种算法进行介绍，
并最终给出 <em class="xref std std-ref">BITCOUNT</em> 命令的具体实现原理。</p>
<div class="section" id="id1">
<h2>二进制位统计算法（1）：遍历算法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>实现 <em class="xref std std-ref">BITCOUNT</em> 命令最简单直接的方法，
就是遍历位数组中的每个二进制位，
并在遇到值为 <code class="docutils literal"><span class="pre">1</span></code> 的二进制位时，
将计数器的值增一。</p>
<p>图 22-17 展示了程序使用遍历算法，
对一个 <code class="docutils literal"><span class="pre">8</span></code> 位长的位数组进行遍历并计数的整个过程。</p>
<p class="graphviz">
<img src="../../_images/graphviz-70fcf38bd5a5444ed083bd0974ab73a63cae97d5.png" alt="digraph {

    counter [label = &quot;counter = 1&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:0;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-53b989b721fa0a05fcead8a0d55d6c5c6f61a72f.png" alt="digraph {

    counter [label = &quot;counter = 1&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:1;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-be9a80e5f92c903f2ce49a006b7e4f4fccf8a436.png" alt="digraph {

    counter [label = &quot;counter = 2&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:2;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-4f35a2f299c2ffe55bc6452fef4214bcaf41d4a4.png" alt="digraph {

    counter [label = &quot;counter = 3&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:3;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-7dc8ff2bb7cbd53c67a6b2daf923a7411a7decc0.png" alt="digraph {

    counter [label = &quot;counter = 3&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:4;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-ecd6b9a5650569dd92503d166b18a0cfa69ea6e7.png" alt="digraph {

    counter [label = &quot;counter = 3&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:5;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-df7d6c9856c1d6c8949909db91d037749ff33eed.png" alt="digraph {

    counter [label = &quot;counter = 4&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:6;

}" />
</p>
<p class="graphviz">
<img src="../../_images/graphviz-306916c78447667ce3470c929e52be25a42212f7.png" alt="digraph {

    label = &quot;\n 图 22-17    遍历算法的运行过程&quot;;

    counter [label = &quot;counter = 4&quot;, shape = plaintext];

    buf [label = &quot; { { buf[0] | &lt;0&gt; 1 | &lt;1&gt; 0 | &lt;2&gt; 1 | &lt;3&gt; 1 | &lt;4&gt; 0 | &lt;5&gt; 0 | &lt;6&gt; 1 | &lt;7&gt; 0 } | { buf[1] （空字符） } } &quot;, shape = record];

    counter -&gt; buf:7;

}" />
</p>
<p>遍历算法虽然实现起来简单，
但效率非常低 ——
因为这个算法在每次循环中只能检查一个二进制位的值是否为 <code class="docutils literal"><span class="pre">1</span></code> ，
所以检查操作执行的次数将与位数组包含的二进制位的数量成正比。</p>
<p>比如说，
假设要检查的位数组的长度为 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span></code> ，
那么按 <code class="docutils literal"><span class="pre">1</span> <span class="pre">MB</span> <span class="pre">=</span> <span class="pre">1,000,000</span> <span class="pre">Byte</span> <span class="pre">=</span> <span class="pre">8,000,000</span> <span class="pre">bit</span></code> 来计算，
使用遍历算法检查长度为 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span></code> 的位数组将需要执行检查操作八亿次（<code class="docutils literal"><span class="pre">100</span> <span class="pre">*</span> <span class="pre">8,000,000</span></code>）！
而对于长度为 <code class="docutils literal"><span class="pre">500</span> <span class="pre">MB</span></code> 的位数组来说，
遍历算法将需要执行检查操作四十亿次！！</p>
<p>尽管遍历算法对单个二进制位的检查可以在很短的时间内完成，
但重复执行上亿次这种检查肯定不是一个高效程序应有的表现，
为了让 <em class="xref std std-ref">BITCOUNT</em> 命令的实现尽可能地高效，
程序必须尽可能地增加每次检查所能处理的二进制位的数量，
从而减少检查操作执行的次数。</p>
</div>
<div class="section" id="id2">
<h2>二进制位统计算法（2）：查表算法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>优化检查操作的一个办法是使用查表法：</p>
<ul class="simple">
<li>对于一个有限集合来说，
集合元素的排列方式是有限的。</li>
<li>而对于一个有限长度的位数组来说，
它能表示的二进制位排列也是有限的。</li>
</ul>
<p>根据这个原理，
我们可以创建一个表，
表的键为某种排列的位数组，
而表的值则是相应位数组中，
值为 <code class="docutils literal"><span class="pre">1</span></code> 的二进制位的数量。</p>
<p>创建了这种表之后，
我们就可以根据输入的位数组进行查表，
在无须对位数组的每个位进行检查的情况下，
直接知道这个位数组包含了多少个值为 <code class="docutils literal"><span class="pre">1</span></code> 的二进制位。</p>
<p>举个例子，
对于 <code class="docutils literal"><span class="pre">8</span></code> 位长的位数组来说，
我们可以创建表格 22-1 ，
通过这个表格，
我们可以一次从位数组中读入 <code class="docutils literal"><span class="pre">8</span></code> 个位，
然后根据这 <code class="docutils literal"><span class="pre">8</span></code> 个位的值进行查表，
直接知道这个值包含了多少个值为 <code class="docutils literal"><span class="pre">1</span></code> 的位。</p>
<hr class="docutils" />
<p>表 22-1    可以快速检查 8 位长的位数组包含多少个 1</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">键（位数组）</th>
<th class="head">值（值为 <code class="docutils literal"><span class="pre">1</span></code> 的位数量）</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0000</span></code></td>
<td><code class="docutils literal"><span class="pre">0</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0001</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0010</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0011</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0100</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0101</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0110</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0000</span> <span class="pre">0111</span></code></td>
<td><code class="docutils literal"><span class="pre">3</span></code></td>
</tr>
<tr class="row-even"><td>...</td>
<td>...</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1111</span> <span class="pre">1101</span></code></td>
<td><code class="docutils literal"><span class="pre">7</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">1111</span> <span class="pre">1110</span></code></td>
<td><code class="docutils literal"><span class="pre">7</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1111</span> <span class="pre">1111</span></code></td>
<td><code class="docutils literal"><span class="pre">8</span></code></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>通过使用表 22-1 ，
我们只需执行一次查表操作，
就可以检查 <code class="docutils literal"><span class="pre">8</span></code> 个二进制位，
和之前介绍的遍历算法相比，
查表法的效率提升了 <code class="docutils literal"><span class="pre">8</span></code> 倍：</p>
<ul class="simple">
<li>以 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span> <span class="pre">=</span> <span class="pre">800,000,000</span> <span class="pre">bit</span></code> （八亿位）来计算，
使用查表法处理长度为 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span></code> 的位数组需要执行查表操作一亿次。</li>
<li>而对于 <code class="docutils literal"><span class="pre">500</span> <span class="pre">MB</span></code> 长的位数组来说，
使用查表法处理该位数组需要执行五亿次查表操作。</li>
</ul>
<p>如果我们创建一个更大的表的话，
那么每次查表所能处理的位就会更多，
从而减少查表操作执行的次数：</p>
<ul class="simple">
<li>如果我们将表键的大小扩展为 <code class="docutils literal"><span class="pre">16</span></code> 位，
那么每次查表就可以处理 <code class="docutils literal"><span class="pre">16</span></code> 个二进制位，
检查 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span></code> 长的二进制位只需要五千万次查表，
检查 <code class="docutils literal"><span class="pre">500</span> <span class="pre">MB</span></code> 长的二进制位只需要两亿五千万次查表。</li>
<li>如果我们将表键的大小扩展为 <code class="docutils literal"><span class="pre">32</span></code> 位，
那么每次查表就可以处理 <code class="docutils literal"><span class="pre">32</span></code> 个二进制位，
检查 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span></code> 长的二进制位只需要两千五百万次查表，
检查 <code class="docutils literal"><span class="pre">500</span> <span class="pre">MB</span></code> 长的二进制位只需要一亿两千五百万次查表。</li>
</ul>
<p>初看起来，
只要我们创建一个足够大的表，
那么统计工作就可以轻易地完成，
但这个问题实际上并没有那么简单，
因为查表法的实际效果会受到内存和缓存两方面因素的限制：</p>
<ul class="simple">
<li>因为查表法是典型的空间换时间策略 ——
算法在计算方面节约的时间是通过花费额外的内存换取而来的，
节约的时间越多，
花费的内存就越大。
对于我们这里讨论的统计二进制位的问题来说，
创建键长为 <code class="docutils literal"><span class="pre">8</span></code> 位的表仅需数百个字节，
创建键长为 <code class="docutils literal"><span class="pre">16</span></code> 位的表也仅需数百个 <code class="docutils literal"><span class="pre">KB</span></code> ，
但创建键长为 <code class="docutils literal"><span class="pre">32</span></code> 位的表却需要十多个 <code class="docutils literal"><span class="pre">GB</span></code> 。
在实际中，
服务器只可能接受数百个字节或者数百 <code class="docutils literal"><span class="pre">KB</span></code> 的内存消耗。</li>
<li>除了内存大小的问题之外，
查表法的效果还会受到 CPU 缓存的限制：
对于固定大小的 CPU 缓存来说，
创建的表格越大，
CPU 缓存所能保存的内容相比整个表格的比例就越少，
查表时出现缓存不命中（cache miss）的情况就会越高，
缓存的换入和换出操作就会越频繁，
最终影响查表法的实际效率。</li>
</ul>
<p>由于以上列举的两个原因，
我们可以得出结论，
查表法是一种比遍历算法更好的统计办法，
但受限于查表法带来的内存压力，
以及缓存不命中可能带来的影响，
我们只能考虑创建键长为 <code class="docutils literal"><span class="pre">8</span></code> 位或者键长为 <code class="docutils literal"><span class="pre">16</span></code> 位的表，
而这两种表带来的效率提升，
对于处理非常长的位数组来说仍然远远不够。</p>
<p>为了高效地实现 <em class="xref std std-ref">BITCOUNT</em> 命令，
我们需要一种不会带来内存压力、并且可以在一次检查中统计多个二进制位的算法 ——
接下来要介绍的 variable-precision SWAR 算法就是这样一种算法。</p>
</div>
<div class="section" id="variable-precision-swar">
<h2>二进制位统计算法（3）：variable-precision SWAR 算法<a class="headerlink" href="#variable-precision-swar" title="Permalink to this headline">¶</a></h2>
<p><em class="xref std std-ref">BITCOUNT</em> 命令要解决的问题 ——
统计一个位数组中非 <code class="docutils literal"><span class="pre">0</span></code> 二进制位的数量，
在数学上被称为“计算<a class="reference external" href="http://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>（<a class="reference external" href="http://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a>）”。</p>
<p>因为汉明重量经常被用于信息论、编码理论和密码学，
所以研究人员针对计算汉明重量开发了多种不同的算法，
一些处理器甚至直接带有计算汉明重量的指令，
而对于不具备这种特殊指令的普通处理器来说，
目前已知效率最好的通用算法为 variable-precision SWAR 算法，
该算法通过一系列位移和位运算操作，
可以在常数时间内计算多个字节的汉明重量，
并且不需要使用任何额外的内存。</p>
<p>以下是一个处理 32 位长度位数组的 variable-precision SWAR 算法的实现：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">uint32_t</span> <span class="nf">swar</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 步骤 1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x55555555</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x55555555</span><span class="p">);</span>

    <span class="c1">// 步骤 2</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">);</span>

    <span class="c1">// 步骤 3</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x0F0F0F0F</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F0F0F0F</span><span class="p">);</span>

    <span class="c1">// 步骤 4</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="mh">0x01010101</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>以下是调用 <code class="docutils literal"><span class="pre">swar(bitarray)</span></code> 的执行步骤：</p>
<ul class="simple">
<li>步骤 1 计算出的值 <code class="docutils literal"><span class="pre">i</span></code> 的二进制表示可以按每两个二进制位为一组进行分组，
各组的十进制表示就是该组的汉明重量。</li>
<li>步骤 2 计算出的值 <code class="docutils literal"><span class="pre">i</span></code> 的二进制表示可以按每四个二进制位为一组进行分组，
各组的十进制表示就是该组的汉明重量。</li>
<li>步骤 3 计算出的值 <code class="docutils literal"><span class="pre">i</span></code> 的二进制表示可以按每八个二进制位为一组进行分组，
各组的十进制表示就是该组的汉明重量。</li>
<li>步骤 4 的 <code class="docutils literal"><span class="pre">i*0x01010101</span></code> 语句计算出 <code class="docutils literal"><span class="pre">bitarray</span></code> 的汉明重量并记录在二进制位的最高八位，
而 <code class="docutils literal"><span class="pre">&gt;&gt;24</span></code> 语句则通过右移运算，
将 <code class="docutils literal"><span class="pre">bitarray</span></code> 的汉明重量移动到最低八位，
得出的结果就是 <code class="docutils literal"><span class="pre">bitarray</span></code> 的汉明重量。</li>
</ul>
<p>举个例子，
对于调用 <code class="docutils literal"><span class="pre">swar(0x3A70F21B)</span></code> ，
程序在第一步将计算出值 <code class="docutils literal"><span class="pre">0x2560A116</span></code> ，
这个值的每两个二进制位的十进制表示记录了 <code class="docutils literal"><span class="pre">0x3A70F21B</span></code> 每两个二进制位的汉明重量，
如表 22-2 所示。</p>
<hr class="docutils" />
<p>表 22-2    在对二进制进行两位分组下， 0x3A70F21B 的汉明重量</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">值</th>
<th class="head" colspan="16">分组</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0x3A70F21B</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">11</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">11</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">11</span></code></td>
<td><code class="docutils literal"><span class="pre">11</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">11</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0x2560A116</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">00</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">01</span></code></td>
<td><code class="docutils literal"><span class="pre">10</span></code></td>
</tr>
<tr class="row-even"><td>汉明重量</td>
<td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>之后，程序在第二步将计算出值 <code class="docutils literal"><span class="pre">0x22304113</span></code> ，
这个值的每四个二进制位的十进制表示记录了 <code class="docutils literal"><span class="pre">0x3A70F21B</span></code> 每四个二进制位的汉明重量，
如表 22-3 所示。</p>
<hr class="docutils" />
<p>表 22-3    在对二进制进行四位分组下， 0x3A70F21B 的汉明重量</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">值</th>
<th class="head" colspan="8">分组</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0x3A70F21B</span></code></td>
<td><code class="docutils literal"><span class="pre">0011</span></code></td>
<td><code class="docutils literal"><span class="pre">1010</span></code></td>
<td><code class="docutils literal"><span class="pre">0111</span></code></td>
<td><code class="docutils literal"><span class="pre">0000</span></code></td>
<td><code class="docutils literal"><span class="pre">1111</span></code></td>
<td><code class="docutils literal"><span class="pre">0010</span></code></td>
<td><code class="docutils literal"><span class="pre">0001</span></code></td>
<td><code class="docutils literal"><span class="pre">1011</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0x22304113</span></code></td>
<td><code class="docutils literal"><span class="pre">0010</span></code></td>
<td><code class="docutils literal"><span class="pre">0010</span></code></td>
<td><code class="docutils literal"><span class="pre">0011</span></code></td>
<td><code class="docutils literal"><span class="pre">0000</span></code></td>
<td><code class="docutils literal"><span class="pre">0100</span></code></td>
<td><code class="docutils literal"><span class="pre">0001</span></code></td>
<td><code class="docutils literal"><span class="pre">0001</span></code></td>
<td><code class="docutils literal"><span class="pre">0011</span></code></td>
</tr>
<tr class="row-even"><td>汉明重量</td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">3</span></code></td>
<td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">4</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">3</span></code></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>接下来，程序在第三步将计算出值 <code class="docutils literal"><span class="pre">0x4030504</span></code> ，
这个值的每八个二进制位的十进制表示记录了 <code class="docutils literal"><span class="pre">0x3A70F21B</span></code> 每八个二进制位的汉明重量，
如表 22-4 所示。</p>
<hr class="docutils" />
<p>表 22-4    在对二进制进行八位分组下， 0x3A70F21B 的汉明重量</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="19%" />
<col width="19%" />
<col width="19%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">值</th>
<th class="head" colspan="4">分组</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0x3A70F21B</span></code></td>
<td><code class="docutils literal"><span class="pre">00111010</span></code></td>
<td><code class="docutils literal"><span class="pre">01110000</span></code></td>
<td><code class="docutils literal"><span class="pre">11110010</span></code></td>
<td><code class="docutils literal"><span class="pre">00011011</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0x4030504</span></code></td>
<td><code class="docutils literal"><span class="pre">00000100</span></code></td>
<td><code class="docutils literal"><span class="pre">00000011</span></code></td>
<td><code class="docutils literal"><span class="pre">00000101</span></code></td>
<td><code class="docutils literal"><span class="pre">00000100</span></code></td>
</tr>
<tr class="row-even"><td>汉明重量</td>
<td><code class="docutils literal"><span class="pre">4</span></code></td>
<td><code class="docutils literal"><span class="pre">3</span></code></td>
<td><code class="docutils literal"><span class="pre">5</span></code></td>
<td><code class="docutils literal"><span class="pre">4</span></code></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>在第四步，程序首先计算 <code class="docutils literal"><span class="pre">0x4030504</span> <span class="pre">*</span> <span class="pre">0x01010101</span> <span class="pre">=</span> <span class="pre">0x100c0904</span></code> ，将汉明重量聚集到二进制位的最高八位，如表 22-5 所示。</p>
<hr class="docutils" />
<p>表 22-5    0x3A70F21B 的汉明重量聚集在 0x100c0904 的最高八位</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="23%" />
<col width="21%" />
<col width="20%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">值</th>
<th class="head"><code class="docutils literal"><span class="pre">24</span></code> 位至 <code class="docutils literal"><span class="pre">31</span></code> 位</th>
<th class="head"><code class="docutils literal"><span class="pre">16</span></code> 至 <code class="docutils literal"><span class="pre">23</span></code> 位</th>
<th class="head"><code class="docutils literal"><span class="pre">8</span></code> 至 <code class="docutils literal"><span class="pre">15</span></code> 位</th>
<th class="head"><code class="docutils literal"><span class="pre">0</span></code> 至 <code class="docutils literal"><span class="pre">7</span></code> 位</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0x100c0904</span></code></td>
<td><code class="docutils literal"><span class="pre">00010000</span></code></td>
<td><code class="docutils literal"><span class="pre">00001100</span></code></td>
<td><code class="docutils literal"><span class="pre">00001001</span></code></td>
<td><code class="docutils literal"><span class="pre">00000100</span></code></td>
</tr>
<tr class="row-odd"><td>汉明重量</td>
<td><code class="docutils literal"><span class="pre">16</span></code></td>
<td>无用值</td>
<td>无用值</td>
<td>无用值</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>之后程序计算 <code class="docutils literal"><span class="pre">0x100c0904</span> <span class="pre">&gt;&gt;</span> <span class="pre">24</span></code> ，
将汉明重量移动到低八位，
最终得出值 <code class="docutils literal"><span class="pre">0x10</span></code> ，
也即是十进制值 <code class="docutils literal"><span class="pre">16</span></code> ，
这个值就是 <code class="docutils literal"><span class="pre">0x3A70F21B</span></code> 的汉明重量，
如表 22-6 所示。</p>
<hr class="docutils" />
<p>表 22-6    进行移位之后，得出 0x3A70F21B 的汉明重量</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="23%" />
<col width="21%" />
<col width="20%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">值</th>
<th class="head"><code class="docutils literal"><span class="pre">24</span></code> 位至 <code class="docutils literal"><span class="pre">31</span></code> 位</th>
<th class="head"><code class="docutils literal"><span class="pre">16</span></code> 至 <code class="docutils literal"><span class="pre">23</span></code> 位</th>
<th class="head"><code class="docutils literal"><span class="pre">8</span></code> 至 <code class="docutils literal"><span class="pre">15</span></code> 位</th>
<th class="head"><code class="docutils literal"><span class="pre">0</span></code> 至 <code class="docutils literal"><span class="pre">7</span></code> 位</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0x10</span></code></td>
<td><code class="docutils literal"><span class="pre">00000000</span></code></td>
<td><code class="docutils literal"><span class="pre">00000000</span></code></td>
<td><code class="docutils literal"><span class="pre">00000000</span></code></td>
<td><code class="docutils literal"><span class="pre">00010000</span></code></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p><code class="docutils literal"><span class="pre">swar</span></code> 函数每次执行可以计算 <code class="docutils literal"><span class="pre">32</span></code> 个二进制位的汉明重量，
它比之前介绍的遍历算法要快 <code class="docutils literal"><span class="pre">32</span></code> 倍，
比键长为 <code class="docutils literal"><span class="pre">8</span></code> 位的查表法快 <code class="docutils literal"><span class="pre">4</span></code> 倍，
比键长为 <code class="docutils literal"><span class="pre">16</span></code> 位的查表法快 <code class="docutils literal"><span class="pre">2</span></code> 倍，
并且因为 <code class="docutils literal"><span class="pre">swar</span></code> 函数是单纯的计算操作，
所以它无须像查表法那样，
使用额外的内存。</p>
<p>另外，
因为 <code class="docutils literal"><span class="pre">swar</span></code> 函数是一个常数复杂度的操作，
所以我们可以按照自己的需要，
在一次循环中多次执行 <code class="docutils literal"><span class="pre">swar</span></code> ，
从而按倍数提升计算汉明重量的效率：</p>
<ul class="simple">
<li>比如说，
如果我们在一次循环中调用两次 <code class="docutils literal"><span class="pre">swar</span></code> 函数，
那么计算汉明重量的效率就从之前的一次循环计算 <code class="docutils literal"><span class="pre">32</span></code> 位提升到了一次循环计算 <code class="docutils literal"><span class="pre">64</span></code> 位。</li>
<li>又比如说，
如果我们在一次循环中调用四次 <code class="docutils literal"><span class="pre">swar</span></code> 函数，
那么一次循环就可以计算 <code class="docutils literal"><span class="pre">128</span></code> 个二进制位的汉明重量，
这比每次循环只调用一次 <code class="docutils literal"><span class="pre">swar</span></code> 函数要快四倍！</li>
</ul>
<p>当然，
在一个循环里执行多个 <code class="docutils literal"><span class="pre">swar</span></code> 调用这种优化方式是有极限的：
一旦循环中处理的位数组的大小超过了缓存的大小，
这种优化的效果就会降低并最终消失。</p>
</div>
<div class="section" id="redis">
<h2>二进制位统计算法（4）： Redis 的实现<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h2>
<p><em class="xref std std-ref">BITCOUNT</em> 命令的实现用到了查表和 variable-precision SWAR 两种算法：</p>
<ul class="simple">
<li>查表算法使用键长为 <code class="docutils literal"><span class="pre">8</span></code> 位的表，
表中记录了从 <code class="docutils literal"><span class="pre">0000</span> <span class="pre">0000</span></code> 到 <code class="docutils literal"><span class="pre">1111</span> <span class="pre">1111</span></code> 在内的所有二进制位的汉明重量。</li>
<li>至于 variable-precision SWAR 算法方面，
<em class="xref std std-ref">BITCOUNT</em> 命令在每次循环中载入 <code class="docutils literal"><span class="pre">128</span></code> 个二进制位，
然后调用四次 32 位 variable-precision SWAR 算法来计算这 <code class="docutils literal"><span class="pre">128</span></code> 个二进制位的汉明重量。</li>
</ul>
<p>在执行 <em class="xref std std-ref">BITCOUNT</em> 命令时，
程序会根据未处理的二进制位的数量来决定使用那种算法：</p>
<ul class="simple">
<li>如果未处理的二进制位的数量大于等于 <code class="docutils literal"><span class="pre">128</span></code> 位，
那么程序使用 variable-precision SWAR 算法来计算二进制位的汉明重量。</li>
<li>如果未处理的二进制位的数量小于 <code class="docutils literal"><span class="pre">128</span></code> 位，
那么程序使用查表算法来计算二进制位的汉明重量。</li>
</ul>
<p>以下伪代码展示了 <em class="xref std std-ref">BITCOUNT</em> 命令的实现原理：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 一个表，记录了所有八位长位数组的汉明重量</span>
<span class="c"># 程序将 8 位长的位数组转换成无符号整数，并在表中进行索引</span>
<span class="c"># 例如，对于输入 0000 0011 ，程序将二进制转换为无符号整数 3</span>
<span class="c"># 然后取出 weight_in_byte[3] 的值 2</span>
<span class="c"># 2 就是 0000 0011 的汉明重量</span>
<span class="n">weight_in_byte</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">/*...*/</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">BITCOUNT</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>

    <span class="c"># 计算位数组包含了多少个二进制位</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count_bit</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span>

    <span class="c"># 初始化汉明重量为零</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># 如果未处理的二进制位大于等于 128 位</span>
    <span class="c"># 那么使用 variable-precision SWAR 算法来处理</span>
    <span class="k">while</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">:</span>

        <span class="c"># 四个 swar 调用，每个调用计算 32 个二进制位的汉明重量</span>
        <span class="c"># 注意： bits[i:j] 中的索引 j 是不包含在取值范围之内的</span>
        <span class="n">weight</span> <span class="o">+=</span> <span class="n">swar</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">])</span>
        <span class="n">weight</span> <span class="o">+=</span> <span class="n">swar</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">32</span><span class="p">:</span><span class="mi">64</span><span class="p">])</span>
        <span class="n">weight</span> <span class="o">+=</span> <span class="n">swar</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">64</span><span class="p">:</span><span class="mi">96</span><span class="p">])</span>
        <span class="n">weight</span> <span class="o">+=</span> <span class="n">swar</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">96</span><span class="p">:</span><span class="mi">128</span><span class="p">])</span>

        <span class="c"># 移动指针，略过已处理的位，指向未处理的位</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">128</span><span class="p">:]</span>
        <span class="c"># 减少未处理位的长度</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="mi">128</span>

    <span class="c"># 如果执行到这里，说明未处理的位数量不足 128 位</span>
    <span class="c"># 那么使用查表法来计算汉明重量</span>
    <span class="k">while</span> <span class="n">count</span><span class="p">:</span>

        <span class="c"># 将 8 个位转换成无符号整数，作为查表的索引（键）</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">bits_to_unsigned_int</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
        <span class="n">weight</span> <span class="o">+=</span> <span class="n">weight_in_byte</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="c"># 移动指针，略过已处理的位，指向未处理的位</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">8</span><span class="p">:]</span>
        <span class="c"># 减少未处理位的长度</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="mi">8</span>

<span class="c"># 计算完毕，返回输入二进制位的汉明重量</span>
<span class="k">return</span> <span class="n">weight</span>
</pre></div>
</div>
<p>这个 <em class="xref std std-ref">BITCOUNT</em> 实现的算法复杂度为 <img class="math" src="../../_images/math/03e5516c1889957839a83599a7a7c92de1e380f4.png" alt="O(n)"/> ，
其中 <img class="math" src="../../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> 为输入二进制位的数量。</p>
<p>更具体一点，
我们可以用以下公式来计算 <em class="xref std std-ref">BITCOUNT</em> 命令在处理长度为 <img class="math" src="../../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> 的二进制位输入时，
命令中的两个循环需要执行的次数：</p>
<ol class="arabic simple">
<li>第一个循环的执行次数可以用公式 <img class="math" src="../../_images/math/8dc11b3e4e4af5c8b350a981c797161433763473.png" alt="loop_{1} = \lfloor n \div 128 \rfloor"/> 计算得出。</li>
<li>第二个循环的执行次数可以用公式 <img class="math" src="../../_images/math/00a5e651766725d53e017778bbb152d04de569bc.png" alt="loop_{2} = n \bmod 128"/> 计算得出。</li>
</ol>
<p>以 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span> <span class="pre">=</span> <span class="pre">800,000,000</span> <span class="pre">bit</span></code> 来计算，
<em class="xref std std-ref">BITCOUNT</em> 命令处理一个 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span></code> 长的位数组共需要执行第一个循环六百二十五万次，
第二个循环零次。
以 <code class="docutils literal"><span class="pre">500</span> <span class="pre">MB</span> <span class="pre">=</span> <span class="pre">4,000,000,000</span> <span class="pre">bit</span></code> 来计算，
<em class="xref std std-ref">BITCOUNT</em> 命令处理一个 <code class="docutils literal"><span class="pre">500</span> <span class="pre">MB</span></code> 长的位数组共需要执行第一个循环三千一百二十五万次，
第二个循环零次。</p>
<p>通过使用更好的算法，
我们将计算 <code class="docutils literal"><span class="pre">100</span> <span class="pre">MB</span></code> 和 <code class="docutils literal"><span class="pre">500</span> <span class="pre">MB</span></code> 长的二进制位所需的循环次数从最开始使用遍历算法时的数亿甚至数十亿次减少到了数百万次和数千万次。</p>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisbookv1'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, 黄健宏（huangz）.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>