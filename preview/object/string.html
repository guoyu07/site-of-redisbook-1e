<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>字符串对象 &mdash; Redis 设计与实现</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Redis 设计与实现" href="../../index.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>字符串对象<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>字符串对象的编码可以是 <code class="docutils literal"><span class="pre">int</span></code> 、 <code class="docutils literal"><span class="pre">raw</span></code> 或者 <code class="docutils literal"><span class="pre">embstr</span></code> 。</p>
<p>如果一个字符串对象保存的是整数值，
并且这个整数值可以用 <code class="docutils literal"><span class="pre">long</span></code> 类型来表示，
那么字符串对象会将整数值保存在字符串对象结构的 <code class="docutils literal"><span class="pre">ptr</span></code> 属性里面（将 <code class="docutils literal"><span class="pre">void*</span></code> 转换成 <code class="docutils literal"><span class="pre">long</span></code> ），
并将字符串对象的编码设置为 <code class="docutils literal"><span class="pre">int</span></code> 。</p>
<p>举个例子，
如果我们执行以下 <span class="xref std std-ref">SET</span> 命令，
那么服务器将创建一个如图 8-1 所示的 <code class="docutils literal"><span class="pre">int</span></code> 编码的字符串对象作为 <code class="docutils literal"><span class="pre">number</span></code> 键的值：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">number</span> <span class="mi">10086</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">number</span>
<span class="s">&quot;int&quot;</span>
</pre></div>
</div>
<p class="graphviz">
<img src="../../_images/graphviz-c0ba08ec03934562687cc3cb79580e76edef81e3.png" alt="digraph {

    label = &quot;\n 图 8-1    int 编码的字符串对象&quot;;

    rankdir = LR;

    node [shape = record];

    redisObject [label = &quot; redisObject | type \n REDIS_STRING | encoding \n REDIS_ENCODING_INT | &lt;ptr&gt; ptr | ... &quot;];

    node [shape = plaintext];

    number [label = &quot;10086&quot;]

    redisObject:ptr -&gt; number;

}" />
</p>
<p>如果字符串对象保存的是一个字符串值，
并且这个字符串值的长度大于 <code class="docutils literal"><span class="pre">39</span></code> 字节，
那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，
并将对象的编码设置为 <code class="docutils literal"><span class="pre">raw</span></code> 。</p>
<p>举个例子，
如果我们执行以下命令，
那么服务器将创建一个如图 8-2 所示的 <code class="docutils literal"><span class="pre">raw</span></code> 编码的字符串对象作为 <code class="docutils literal"><span class="pre">story</span></code> 键的值：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">story</span> <span class="s">&quot;Long, long, long ago there lived a king ...&quot;</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">STRLEN</span> <span class="n">story</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">43</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">story</span>
<span class="s">&quot;raw&quot;</span>
</pre></div>
</div>
<p class="graphviz">
<img src="../../_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png" alt="digraph {

    label = &quot;\n 图 8-2    raw 编码的字符串对象&quot;;

    rankdir = LR;

    node [shape = record];

    redisObject [label = &quot; redisObject | type \n REDIS_STRING | encoding \n REDIS_ENCODING_RAW | &lt;ptr&gt; ptr | ... &quot;];

    sdshdr [label = &quot; &lt;head&gt; sdshdr | free \n 0 | len \n 43 | &lt;buf&gt; buf&quot;];

    buf [label = &quot; { 'L' | 'o' | 'n' | 'g' | ... | 'k' | 'i' | 'n' | 'g' | ' ' | '.' | '.' | '.' | '\\0' } &quot; ];

    //

    redisObject:ptr -&gt; sdshdr:head;
    sdshdr:buf -&gt; buf;

}" />
</p>
<p>如果字符串对象保存的是一个字符串值，
并且这个字符串值的长度小于等于 <code class="docutils literal"><span class="pre">39</span></code> 字节，
那么字符串对象将使用 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的方式来保存这个字符串值。</p>
<p><code class="docutils literal"><span class="pre">embstr</span></code> 编码是专门用于保存短字符串的一种优化编码方式，
这种编码和 <code class="docutils literal"><span class="pre">raw</span></code> 编码一样，
都使用 <code class="docutils literal"><span class="pre">redisObject</span></code> 结构和 <code class="docutils literal"><span class="pre">sdshdr</span></code> 结构来表示字符串对象，
但 <code class="docutils literal"><span class="pre">raw</span></code> 编码会调用两次内存分配函数来分别创建 <code class="docutils literal"><span class="pre">redisObject</span></code> 结构和 <code class="docutils literal"><span class="pre">sdshdr</span></code> 结构，
而 <code class="docutils literal"><span class="pre">embstr</span></code> 编码则通过调用一次内存分配函数来分配一块连续的空间，
空间中依次包含 <code class="docutils literal"><span class="pre">redisObject</span></code> 和 <code class="docutils literal"><span class="pre">sdshdr</span></code> 两个结构，
如图 8-3 所示。</p>
<p class="graphviz">
<img src="../../_images/graphviz-9512800b17c43f60ef9568c6b0b4921c90f7f862.png" alt="digraph {

    label = &quot;\n 图 8-3    embstr 编码创建的内存块结构&quot;;

    node [shape = record];

    embstr [ label = &quot; { redisObject | { type | encoding | &lt;ptr&gt; ptr | ... } } |  { sdshdr | { free | len | &lt;buf&gt; buf }} &quot; ];

}" />
</p>
<p><code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象在执行命令时，
产生的效果和 <code class="docutils literal"><span class="pre">raw</span></code> 编码的字符串对象执行命令时产生的效果是相同的，
但使用 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象来保存短字符串值有以下好处：</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">embstr</span></code> 编码将创建字符串对象所需的内存分配次数从 <code class="docutils literal"><span class="pre">raw</span></code> 编码的两次降低为一次。</li>
<li>释放 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象只需要调用一次内存释放函数，
而释放 <code class="docutils literal"><span class="pre">raw</span></code> 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象的所有数据都保存在一块连续的内存里面，
所以这种编码的字符串对象比起 <code class="docutils literal"><span class="pre">raw</span></code> 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ol>
<p>作为例子，
以下命令创建了一个 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象作为 <code class="docutils literal"><span class="pre">msg</span></code> 键的值，
值对象的样子如图 8-4 所示：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s">&quot;hello&quot;</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">msg</span>
<span class="s">&quot;embstr&quot;</span>
</pre></div>
</div>
<p class="graphviz">
<img src="../../_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png" alt="digraph {

    label = &quot;\n 图 8-4    embstr 编码的字符串对象&quot;;

    node [shape = record];

    embstr [ label = &quot; { redisObject | { type \n REDIS_STRING | encoding \n REDIS_ENCODING_EMBSTR | &lt;ptr&gt; ptr | ... } } |  { sdshdr | { free \n 0 | len \n 5 | { buf | { &lt;buf&gt; 'h' | 'e' | 'l' | 'l' | 'o' | '\\0'}} }} &quot; ];

    embstr:ptr -&gt; embstr:buf;

}" />
</p>
<p>最后要说的是，
可以用 <code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code> 类型表示的浮点数在 Redis 中也是作为字符串值来保存的：
如果我们要保存一个浮点数到字符串对象里面，
那么程序会先将这个浮点数转换成字符串值，
然后再保存起转换所得的字符串值。</p>
<p>举个例子，
执行以下代码将创建一个包含 <code class="docutils literal"><span class="pre">3.14</span></code> 的字符串表示 <code class="docutils literal"><span class="pre">&quot;3.14&quot;</span></code> 的字符串对象：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">pi</span> <span class="mf">3.14</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">pi</span>
<span class="s">&quot;embstr&quot;</span>
</pre></div>
</div>
<p>在有需要的时候，
程序会将保存在字符串对象里面的字符串值转换回浮点数值，
执行某些操作，
然后再将执行操作所得的浮点数值转换回字符串值，
并继续保存在字符串对象里面。</p>
<p>举个例子，
如果我们执行以下代码的话：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">INCRBYFLOAT</span> <span class="n">pi</span> <span class="mf">2.0</span>
<span class="s">&quot;5.14&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">pi</span>
<span class="s">&quot;embstr&quot;</span>
</pre></div>
</div>
<p>那么程序首先会取出字符串对象里面保存的字符串值 <code class="docutils literal"><span class="pre">&quot;3.14&quot;</span></code> ，
将它转换回浮点数值 <code class="docutils literal"><span class="pre">3.14</span></code> ，
然后把 <code class="docutils literal"><span class="pre">3.14</span></code> 和 <code class="docutils literal"><span class="pre">2.0</span></code> 相加得出的值 <code class="docutils literal"><span class="pre">5.14</span></code> 转换成字符串 <code class="docutils literal"><span class="pre">&quot;5.14&quot;</span></code> ，
并将这个 <code class="docutils literal"><span class="pre">&quot;5.14&quot;</span></code> 保存到字符串对象里面。</p>
<p>表 8-6 总结并列出了字符串对象保存各种不同类型的值所使用的编码方式。</p>
<hr class="docutils" />
<p>表 8-6    字符串对象保存各类型值的编码方式</p>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">值</th>
<th class="head">编码</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>可以用 <code class="docutils literal"><span class="pre">long</span></code> 类型保存的整数。</td>
<td><code class="docutils literal"><span class="pre">int</span></code></td>
</tr>
<tr class="row-odd"><td>可以用 <code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code> 类型保存的浮点数。</td>
<td><code class="docutils literal"><span class="pre">embstr</span></code> 或者 <code class="docutils literal"><span class="pre">raw</span></code></td>
</tr>
<tr class="row-even"><td>字符串值，
或者因为长度太大而没办法用 <code class="docutils literal"><span class="pre">long</span></code> 类型表示的整数，
又或者因为长度太大而没办法用 <code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code> 类型表示的浮点数。</td>
<td><code class="docutils literal"><span class="pre">embstr</span></code> 或者 <code class="docutils literal"><span class="pre">raw</span></code></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<div class="section" id="id2">
<h2>编码的转换<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">int</span></code> 编码的字符串对象和 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象在条件满足的情况下，
会被转换为 <code class="docutils literal"><span class="pre">raw</span></code> 编码的字符串对象。</p>
<p>对于 <code class="docutils literal"><span class="pre">int</span></code> 编码的字符串对象来说，
如果我们向对象执行了一些命令，
使得这个对象保存的不再是整数值，
而是一个字符串值，
那么字符串对象的编码将从 <code class="docutils literal"><span class="pre">int</span></code> 变为 <code class="docutils literal"><span class="pre">raw</span></code> 。</p>
<p>在下面的示例中，
我们通过 <span class="xref std std-ref">APPEND</span> 命令，
向一个保存整数值的字符串对象追加了一个字符串值，
因为追加操作只能对字符串值执行，
所以程序会先将之前保存的整数值 <code class="docutils literal"><span class="pre">10086</span></code> 转换为字符串值 <code class="docutils literal"><span class="pre">&quot;10086&quot;</span></code> ，
然后再执行追加操作，
操作的执行结果就是一个 <code class="docutils literal"><span class="pre">raw</span></code> 编码的、保存了字符串值的字符串对象：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">number</span> <span class="mi">10086</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">number</span>
<span class="s">&quot;int&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">APPEND</span> <span class="n">number</span> <span class="s">&quot; is a good number!&quot;</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">23</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">number</span>
<span class="s">&quot;10086 is a good number!&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">number</span>
<span class="s">&quot;raw&quot;</span>
</pre></div>
</div>
<p>另外，
因为 Redis 没有为 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象编写任何相应的修改程序
（只有 <code class="docutils literal"><span class="pre">int</span></code> 编码的字符串对象和 <code class="docutils literal"><span class="pre">raw</span></code> 编码的字符串对象有这些程序），
所以 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象实际上是只读的：
当我们对 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象执行任何修改命令时，
程序会先将对象的编码从 <code class="docutils literal"><span class="pre">embstr</span></code> 转换成 <code class="docutils literal"><span class="pre">raw</span></code> ，
然后再执行修改命令；
因为这个原因，
<code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象在执行修改命令之后，
总会变成一个 <code class="docutils literal"><span class="pre">raw</span></code> 编码的字符串对象。</p>
<p>以下代码展示了一个 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的字符串对象在执行 <span class="xref std std-ref">APPEND</span> 命令之后，
对象的编码从 <code class="docutils literal"><span class="pre">embstr</span></code> 变为 <code class="docutils literal"><span class="pre">raw</span></code> 的例子：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s">&quot;hello world&quot;</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">msg</span>
<span class="s">&quot;embstr&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">APPEND</span> <span class="n">msg</span> <span class="s">&quot; again!&quot;</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">18</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">OBJECT</span> <span class="n">ENCODING</span> <span class="n">msg</span>
<span class="s">&quot;raw&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>字符串命令的实现<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>因为字符串键的值为字符串对象，
所以用于字符串键的所有命令都是针对字符串对象来构建的，
表 8-7 列举了其中一部分字符串命令，
以及这些命令在不同编码的字符串对象下的实现方法。</p>
<hr class="docutils" />
<p>表 8-7    字符串命令的实现</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="27%" />
<col width="27%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">命令</th>
<th class="head"><code class="docutils literal"><span class="pre">int</span></code> 编码的实现方法</th>
<th class="head"><code class="docutils literal"><span class="pre">embstr</span></code> 编码的实现方法</th>
<th class="head"><code class="docutils literal"><span class="pre">raw</span></code> 编码的实现方法</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="xref std std-ref">SET</span></td>
<td>使用 <code class="docutils literal"><span class="pre">int</span></code> 编码保存值。</td>
<td>使用 <code class="docutils literal"><span class="pre">embstr</span></code> 编码保存值。</td>
<td>使用 <code class="docutils literal"><span class="pre">raw</span></code> 编码保存值。</td>
</tr>
<tr class="row-odd"><td><span class="xref std std-ref">GET</span></td>
<td>拷贝对象所保存的整数值，
将这个拷贝转换成字符串值，
然后向客户端返回这个字符串值。</td>
<td>直接向客户端返回字符串值。</td>
<td>直接向客户端返回字符串值。</td>
</tr>
<tr class="row-even"><td><span class="xref std std-ref">APPEND</span></td>
<td>将对象转换成 <code class="docutils literal"><span class="pre">raw</span></code> 编码，
然后按 <code class="docutils literal"><span class="pre">raw</span></code>
编码的方式执行此操作。</td>
<td>将对象转换成 <code class="docutils literal"><span class="pre">raw</span></code> 编码，
然后按 <code class="docutils literal"><span class="pre">raw</span></code>
编码的方式执行此操作。</td>
<td>调用 <code class="docutils literal"><span class="pre">sdscatlen</span></code> 函数，
将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr class="row-odd"><td><span class="xref std std-ref">INCRBYFLOAT</span></td>
<td>取出整数值并将其转换成
<code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code> 类型的浮点数，
对这个浮点数进行加法计算，
然后将得出的浮点数结果保存起来。</td>
<td>取出字符串值并尝试将其转换成
<code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code> 类型的浮点数，
对这个浮点数进行加法计算，
然后将得出的浮点数结果保存起来。
如果字符串值不能被转换成浮点数，
那么向客户端返回一个错误。</td>
<td>取出字符串值并尝试将其转换成
<code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code> 类型的浮点数，
对这个浮点数进行加法计算，
然后将得出的浮点数结果保存起来。
如果字符串值不能被转换成浮点数，
那么向客户端返回一个错误。</td>
</tr>
<tr class="row-even"><td><span class="xref std std-ref">INCRBY</span></td>
<td>对整数值进行加法计算，
得出的计算结果会作为整数被保存起来。</td>
<td><code class="docutils literal"><span class="pre">embstr</span></code> 编码不能执行此命令，
向客户端返回一个错误。</td>
<td><code class="docutils literal"><span class="pre">raw</span></code> 编码不能执行此命令，
向客户端返回一个错误。</td>
</tr>
<tr class="row-odd"><td><span class="xref std std-ref">DECRBY</span></td>
<td>对整数值进行减法计算，
得出的计算结果会作为整数被保存起来。</td>
<td><code class="docutils literal"><span class="pre">embstr</span></code> 编码不能执行此命令，
向客户端返回一个错误。</td>
<td><code class="docutils literal"><span class="pre">raw</span></code> 编码不能执行此命令，
向客户端返回一个错误。</td>
</tr>
<tr class="row-even"><td><span class="xref std std-ref">STRLEN</span></td>
<td>拷贝对象所保存的整数值，
将这个拷贝转换成字符串值，
计算并返回这个字符串值的长度。</td>
<td>调用 <code class="docutils literal"><span class="pre">sdslen</span></code> 函数，
返回字符串的长度。</td>
<td>调用 <code class="docutils literal"><span class="pre">sdslen</span></code> 函数，
返回字符串的长度。</td>
</tr>
<tr class="row-odd"><td><span class="xref std std-ref">SETRANGE</span></td>
<td>将对象转换成 <code class="docutils literal"><span class="pre">raw</span></code> 编码，
然后按 <code class="docutils literal"><span class="pre">raw</span></code>
编码的方式执行此命令。</td>
<td>将对象转换成 <code class="docutils literal"><span class="pre">raw</span></code> 编码，
然后按 <code class="docutils literal"><span class="pre">raw</span></code>
编码的方式执行此命令。</td>
<td>将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr class="row-even"><td><span class="xref std std-ref">GETRANGE</span></td>
<td>拷贝对象所保存的整数值，
将这个拷贝转换成字符串值，
然后取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody>
</table>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisbookv1'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, 黄健宏（huangz）.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>