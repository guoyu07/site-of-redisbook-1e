BY 选项的实现
------------------------------------

在默认情况下，
:ref:`SORT` 命令使用被排序键包含的元素作为排序的权重，
元素本身决定了元素在排序之后所处的位置。

比如说，
在下面这个例子里面，
排序 ``fruits`` 集合所使用的权重就是 ``"apple"`` 、 ``"banana"`` 、 ``"cherry"`` 三个元素本身：

::

    redis> SADD fruits "apple" "banana" "cherry"
    (integer) 3

    redis> SORT fruits ALPHA
    1) "apple"
    2) "banana"
    3) "cherry"

另一方面，
通过使用 ``BY`` 选项，
:ref:`SORT` 命令可以指定某些字符串键，
或者某个哈希键所包含的某些域（field）来作为元素的权重，
对一个键进行排序。

比如说，
以下这个例子就使用苹果、香蕉、樱桃三种水果的价钱，
对集合键 ``fruits`` 进行了排序：

::

    redis> MSET apple-price 8 banana-price 5.5 cherry-price 7
    OK

    redis> SORT fruits BY *-price
    1) "banana"
    2) "cherry"
    3) "apple"

服务器执行 ``SORT fruits BY *-price`` 命令的详细步骤如下：

1. 创建一个 ``redisSortObject`` 结构数组，
   数组的长度等于 ``fruits`` 集合的大小。

2. 遍历数组，
   将各个数组项的 ``obj`` 指针分别指向 ``fruits`` 集合的各个元素，
   如图 21-9 所示。

3. 遍历数组，
   根据各个数组项的 ``obj`` 指针所指向的集合元素，
   以及 ``BY`` 选项所给定的模式 ``*-price`` ，
   查找相应的权重键：
   
   - 对于 ``"apple"`` 元素，
     查找程序返回权重键 ``"apple-price"`` 。

   - 对于 ``"banana"`` 元素，
     查找程序返回权重键 ``"banana-price"`` 。

   - 对于 ``"cherry"`` 元素，
     查找程序返回权重键 ``"cherry-price"`` 。

4. 将各个权重键的值转换成一个 ``double`` 类型的浮点数，
   然后保存在相应数组项的 ``u.score`` 属性里面，
   如图 21-10 所示：

   - ``"apple"`` 元素的权重键 ``"apple-price"`` 的值转换之后为 ``8.0`` 。

   - ``"banana"`` 元素的权重键 ``"banana-price"`` 的值转换之后为 ``5.5`` 。

   - ``"cherry"`` 元素的权重键 ``"cherry-price"`` 的值转换之后为 ``7.0`` 。

5. 以数组项 ``u.score`` 属性的值为权重，
   对数组进行排序，
   得到一个按 ``u.score`` 属性的值从小到大排序的数组，
   如图 21-11 所示：

   - 权重为 ``5.5`` 的 ``"banana"`` 元素位于数组的索引 ``0`` 位置上。

   - 权重为 ``7.0`` 的 ``"cherry"`` 元素位于数组的索引 ``1`` 位置上。

   - 权重为 ``8.0`` 的 ``"apple"`` 元素位于数组的索引 ``2`` 位置上。

6. 遍历数组，
   依次将数组项的 ``obj`` 指针所指向的集合元素返回给客户端。

其他 ``SORT <key> BY <pattern>`` 命令的执行步骤也和这里给出的步骤类似。

.. graphviz::

    digraph {

        rankdir = LR;

        node [shape = record];

        subgraph cluster_fruits {

            label = "fruits 集合";

            style = dashed;

            apple [label = "StringObject \n \"apple\""];
            banana [label = "StringObject \n \"banana\""];
            cherry [label = "StringObject \n \"cherry\""];

            apple -> cherry -> banana [style = invis];
        }

        subgraph cluster_array {

            style = invis;

            array [label = " array | { <array0> array[0] \n redisSortObject | { <obj0> obj | u } } | { <array1> array[1] \n redisSortObject | { <obj1> obj | u } } | { <array2> array[2] \n redisSortObject | { <obj2> obj | u } } "];
        }
       array:obj0 -> apple;
       array:obj1 -> cherry;
       array:obj2 -> banana;

       label = "\n 图 21-9    将 obj 指针指向集合的各个元素";

    }

.. graphviz::

    digraph {

        rankdir = LR;

        node [shape = record];

        subgraph cluster_fruits {

            label = "fruits 集合";

            style = dashed;

            apple [label = "StringObject \n \"apple\""];
            banana [label = "StringObject \n \"banana\""];
            cherry [label = "StringObject \n \"cherry\""];

            apple -> cherry -> banana [style = invis];
        }

        subgraph cluster_array {

            style = invis;

            array [label = " array | { <array0> array[0] \n redisSortObject | { <obj0> obj | u.score \n 8.0 } } | { <array1> array[1] \n redisSortObject | { <obj1> obj | u.score \n 7.0 } } | { <array2> array[2] \n redisSortObject | { <obj2> obj | u.score \n 5.5 } } "];
        }
       array:obj0 -> apple;
       array:obj1 -> cherry;
       array:obj2 -> banana;

       label = "\n 图 21-10    根据权重键的值设置数组项的 u.score 属性";

    }

.. graphviz::

    digraph {

        rankdir = LR;

        node [shape = record];

        subgraph cluster_fruits {

            label = "fruits 集合";

            style = dashed;

            apple [label = "StringObject \n \"apple\""];
            banana [label = "StringObject \n \"banana\""];
            cherry [label = "StringObject \n \"cherry\""];

            apple -> cherry -> banana [style = invis];
        }

        subgraph cluster_array {

            style = invis;

            array [label = " array | { <array0> array[0] \n redisSortObject | { <obj0> obj | u.score \n 5.5 } } | { <array1> array[1] \n redisSortObject | { <obj1> obj | u.score \n 7.0 } } | { <array2> array[2] \n redisSortObject | { <obj2> obj | u.score \n 8.0 } } "];
        }
       array:obj0 -> banana;
       array:obj1 -> cherry;
       array:obj2 -> apple;

       label = "\n 图 21-11    根据 u.score 属性进行排序之后的数组";

    }


..  BY 选项的查找规则

    1. 包含 '*' 字符、但不包含 "->" 字符串的字符串，比如 ``*-price`` ，用于查找 ``apple-price`` 字符串键。

    2. 包含 '*' 和 "->" 的字符串，比如 ``*-info->price`` ，用于查找 ``apple-info`` 哈希键的 ``price`` 域。


