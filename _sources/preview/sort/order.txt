多个选项的执行顺序
---------------------

前面的章节介绍了 :ref:`SORT` 命令以及相关选项的实现原理，
为了简单起见，
在介绍单个选项的实现原理时，
文章通常只在代码示例中使用被介绍的那个选项，
但在 :ref:`SORT` 命令的实际使用中，
情况并不总是那么简单的 ——
一个 :ref:`SORT` 命令请求通常会用到多个选项，
而这些选项的执行顺序是有先后之分的。


选项的执行顺序
^^^^^^^^^^^^^^^^^^^^^^^^^^^

如果按照选项来划分的话，
一个 :ref:`SORT` 命令的执行过程可以分为以下四步：

1. 排序：
   在这一步，
   命令会使用 ``ALPHA`` 、 ``ASC`` 或 ``DESC`` 、 ``BY`` 这几个选项，
   对输入键进行排序，
   并得到一个排序结果集。

2. 限制排序结果集的长度：
   在这一步，
   命令会使用 ``LIMIT`` 选项，
   对排序结果集的长度进行限制，
   只有 ``LIMIT`` 选项指定的那部分元素会被保留在排序结果集中。

3. 获取外部键：
   在这一步，
   命令会使用 ``GET`` 选项，
   根据排序结果集中的元素，
   以及 ``GET`` 选项指定的模式，
   查找并获取指定键的值，
   并用这些值来作为新的排序结果集。

4. 保存排序结果集：
   在这一步，
   命令会使用 ``STORE`` 选项，
   将排序结果集保存到指定的键上面去。

5. 向客户端返回排序结果集：
   在最后这一步，
   命令遍历排序结果集，
   并依次向客户端返回排序结果集中的元素。

在以上这些步骤中，
后一个步骤必须在前一个步骤完成之后进行。

举个例子，
如果客户端向服务器发送以下命令：

::

    SORT <key> ALPHA DESC BY <by-pattern> LIMIT <offset> <count> GET <get-pattern> STORE <store_key>

那么命令首先会执行：

::

    SORT <key> ALPHA DESC BY <by-pattern>

接着执行：

::

    LIMIT <offset> <count>

然后执行：

::

    GET <get-pattern>

之后执行：

::

    STORE <store_key>

最后，
命令遍历排序结果集，
将结果集中的元素依次返回给客户端。


选项的摆放顺序
^^^^^^^^^^^^^^^^^^^^^^^^^^^

另外要提醒的一点是，
调用 :ref:`SORT` 命令时，
除了 ``GET`` 选项之外，
改变选项的摆放顺序并不会影响 :ref:`SORT` 命令执行这些选项的顺序。

比如说，
命令：

::

    SORT <key> ALPHA DESC BY <by-pattern> LIMIT <offset> <count> GET <get-pattern> STORE <store_key>

和命令：

::

    SORT <key> LIMIT <offset> <count> BY <by-pattern> ALPHA GET <get-pattern> STORE <store_key> DESC

以及命令：

::

    SORT <key> STORE <store_key> DESC BY <by-pattern> GET <get-pattern> ALPHA LIMIT <offset> <count>

都产生完全相同的排序数据集。

不过，
如果命令包含了多个 ``GET`` 选项，
那么在调整选项的位置时，
我们必须保证多个 ``GET`` 选项的摆放顺序不变，
这才可以让排序结果集保持不变。

比如说，
命令：

::

    SORT <key> GET <pattern-a> GET <pattern-b> STORE <store_key>

和命令：

::

    SORT <key> STORE <store_key> GET <pattern-a> GET <pattern-b>

产生的排序结果集是完全一样的，
但如果将两个 ``GET`` 选项的顺序调整一下：

::

    SORT <key> STORE <store_key> GET <pattern-b> GET <pattern-a>

那么这个命令产生的排序结果集就会和前面两个命令产生的排序结果集不同。

因此在调整 :ref:`SORT` 命令各个选项的摆放顺序时，
必须小心处理 ``GET`` 选项。
