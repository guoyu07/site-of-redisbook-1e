ALPHA 选项的实现 
-----------------------------------

通过使用 ``ALPHA`` 选项，
:ref:`SORT` 命令可以对包含字符串值的键进行排序：

::

    SORT <key> ALPHA

以下命令展示了如何使用 :ref:`SORT` 命令对一个包含三个字符串值的集合键进行排序：

::

    redis> SADD fruits apple banana cherry
    (integer) 3

    # 元素在集合中是乱序存放的
    redis> SMEMBERS fruits
    1) "apple"
    2) "cherry"
    3) "banana"

    # 对 fruits 键进行字符串排序
    redis> SORT fruits ALPHA
    1) "apple"
    2) "banana"
    3) "cherry"

服务器执行 ``SORT fruits ALPHA`` 命令的详细步骤如下：

1. 创建一个 ``redisSortObject`` 结构数组，
   数组的长度等于 ``fruits`` 集合的大小。

2. 遍历数组，
   将各个数组项的 ``obj`` 指针分别指向 ``fruits`` 集合的各个元素，
   如图 21-5 所示。

3. 根据 ``obj`` 指针所指向的集合元素，
   对数组进行字符串排序，
   排序后的数组项按集合元素的字符串值从小到大排列：
   因为 ``"apple"`` 、 ``"banana"`` 、 ``"cherry"`` 三个字符串的大小顺序为 ``"apple" < "banana" < "cherry"`` ，
   所以排序后数组的第一项指向 ``"apple"`` 元素，
   第二项指向 ``"banana"`` 元素，
   第三项指向 ``"cherry"`` 元素，
   如图 21-6 所示。

4. 遍历数组，
   依次将数组项的 ``obj`` 指针所指向的元素返回给客户端。 

其他 ``SORT <key> ALPHA`` 命令的执行步骤也和这里给出的 ``SORT fruits ALPHA`` 命令的执行步骤类似。

.. graphviz::

    digraph {

        rankdir = LR;

        node [shape = record];

        subgraph cluster_fruits {

            label = "fruits 集合";

            style = dashed;

            apple [label = "StringObject \n \"apple\""];
            banana [label = "StringObject \n \"banana\""];
            cherry [label = "StringObject \n \"cherry\""];

            apple -> cherry -> banana [style = invis];
        }

        subgraph cluster_array {

            style = invis;

            array [label = " array | { <array0> array[0] \n redisSortObject | { <obj0> obj | u } } | { <array1> array[1] \n redisSortObject | { <obj1> obj | u } } | { <array2> array[2] \n redisSortObject | { <obj2> obj | u } } "];
        }
       array:obj0 -> apple;
       array:obj1 -> cherry;
       array:obj2 -> banana;

       label = "\n 图 21-5    将 obj 指针指向集合的各个元素";

    }

.. graphviz::

    digraph {

        rankdir = LR;

        node [shape = record];

        subgraph cluster_fruits {

            label = "fruits 集合";

            style = dashed;

            apple [label = "StringObject \n \"apple\""];
            banana [label = "StringObject \n \"banana\""];
            cherry [label = "StringObject \n \"cherry\""];

            apple -> cherry -> banana [style = invis];
        }

        subgraph cluster_array {

            style = invis;

            array [label = " array | { <array0> array[0] \n redisSortObject | { <obj0> obj | u } } | { <array1> array[1] \n redisSortObject | { <obj1> obj | u } } | { <array2> array[2] \n redisSortObject | { <obj2> obj | u } } "];
        }
       array:obj0 -> apple;
       array:obj1 -> banana;
       array:obj2 -> cherry;

       label = "\n 图 21-6    按集合元素进行排序后的数组";

    }

..
    .. topic:: 数字值排序和字符串排序的区别

        :ref:`SORT` 命令执行时是否使用 ``ALPHA`` 选项，
        决定了命令对键所执行的排序操作的类型：

        - 如果 :ref:`SORT` 命令没有使用 ``ALPHA`` 选项，
          那么命令对键执行数字值排序。

        - 相反，
          如果 :ref:`SORT` 命令使用了 ``ALPHA`` 选项，
          那么命令对键执行字符串排序。

        :ref:`SORT` 命令的数字值排序和字符串排序都是通过快速排序算法（\ `Quicksort <http://en.wikipedia.org/wiki/Quicksort>`_\ ）来进行的，
        但命令为两种排序设置了不同的对比函数
        （快速排序算法通过使用对比函数在数组中进行元素与元素之间的对比，
        从而决定元素在数组中的位置）。

        其中，
        数字值排序所使用的对比函数可以用以下伪代码描述：

        .. code-block:: python

            def compare_number(x, y):

                if x > y:
                    return 1
                elif x < y:
                    return -1
                else:
                    # x == y
                    return 0

        而字符串排序所使用的对比函数可以用以下伪代码描述：

        .. code-block:: python

            def compare_string(x, y):

                if STORE:

                    # 如果使用了 STORE 选项
                    # 那么使用 memcmp 函数来对比两个字符串
                    return compare_using_memcmp(x, y)

                else:

                    # 如果没有使用 STORE 选项
                    # 那么使用 strcoll 函数来对比两个字符串
                    return compare_using_strcoll(x, y)

        这两个对比函数都产生升序对比的结果，
        也即是说，
        对于输入值 ``x`` 和 ``y`` 来说：

        - 当 ``x`` 的值大于 ``y`` 的值时，函数返回 ``1`` 。

        - 当 ``x`` 的值小于 ``y`` 的值时，函数返回 ``-1`` 。

        - 当 ``x`` 的值和 ``y`` 的值相等时，函数返回 ``0`` 。

        升序对比所产生的排序结果也是升序的
        （元素以从小到大的顺序排列），
        在稍后介绍 ``ASC`` 和 ``DESC`` 选项的时候，
        我们会说明 :ref:`SORT` 命令是如何在使用 ``DESC`` 选项时，
        产生降序排序结果的
        （元素以从大到小的顺序排列）。


    .. topic:: ``SORT`` 命令排序同一个键时可能会产生两种不同的结果

        因为 :ref:`SORT` 命令在执行字符串排序的时候，
        会根据 ``STORE`` 选项的使用情况来选择两种对比方式的其中一种，
        所以对于同一个键来说，
        使用：

        ::

            SORT <key> ALPHA

        所产生的排序结果，
        可能和使用：

        ::

            SORT <key> ALPHA STORE <store_key>

        所产生的结果不同。

        以下 Python 代码展示了一个这种情况的例子：

        .. code-block:: python

            >>> from redis import Redis

            >>> r = Redis()

            >>> r.rpush("msg", u"你好", u"早上好", u"很高兴认识你")
            3L

            >>> for m in r.sort("msg", alpha=True): print(m)    # 没有使用 STORE 选项
            ... 
            很高兴认识你
            你好
            早上好

            >>> r.sort("msg", alpha=True, store="sorted_msg")   # 使用了 STORE 选项
            3L

            >>> for m in r.lrange("sorted_msg", 0, -1): print(m)
            ... 
            你好
            很高兴认识你
            早上好
