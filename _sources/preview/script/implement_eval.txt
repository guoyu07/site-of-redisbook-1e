EVAL 命令的实现
-------------------

..
    通过发送 :ref:`EVAL` 命令，
    客户端可以在 Redis 服务器中执行指定的 Lua 脚本。

    比如说，
    对于以下命令来说：

    ::

        127.0.0.1:6379> EVAL "return 'hello world'" 0
        "hello world"

    Redis 服务器将执行 Lua 脚本：

    ::

        "return 'hello world'"

    并向客户端返回脚本的执行结果：

    ::

        "hello world" 

:ref:`EVAL` 命令的执行过程可以分为以下三个步骤：

1. 根据客户端给定的 Lua 脚本，
   在 Lua 环境中定义一个 Lua 函数。

2. 将客户端给定的脚本保存到 ``lua_scripts`` 字典，
   等待将来进一步使用。

3. 执行刚刚在 Lua 环境中定义的函数，
   以此来执行客户端给定的 Lua 脚本。

以下三个小节将以：

::

    redis> EVAL "return 'hello world'" 0
    "hello world"

命令为示例，
分别介绍 :ref:`EVAL` 命令执行的三个步骤。


定义脚本函数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

..
    所有被服务器执行的 Lua 脚本，
    在 Lua 环境中都会有一个和该脚本相对应的无参数函数：

当客户端向服务器发送 :ref:`EVAL` 命令，
要求执行某个 Lua 脚本的时候，
服务器首先要做的就是在 Lua 环境中，
为传入的脚本定义一个与这个脚本相对应的 Lua 函数：
其中，
Lua 函数的名字由 ``f_`` 前缀加上脚本的 SHA1 校验和（四十个字符长）组成，
而函数的体（body）则是脚本本身。

举个例子，
对于命令：

::

    EVAL "return 'hello world'" 0

来说，
服务器将在 Lua 环境中定义以下函数：

.. code-block:: lua

    function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91()
        return 'hello world'
    end

因为客户端传入的脚本为 ``return 'hello world'`` ，
而这个脚本的 SHA1 校验和为 ``5332031c6b470dc5a0dd9b4bf2030dea6d65de91`` ，
所以函数的名字为 ``f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91`` ，
而函数的体则为 ``return 'hello world'`` 。

..
    在为脚本定义函数之前，
    服务器会先根据函数名检查 Lua 环境，
    只有在函数定义未存在时，
    服务器才会定义 Lua 函数，
    这可以避免 SHA1 值相同的 Lua 脚本互相覆盖，
    并且可以在 Lua 脚本相同时，
    避免重复定义相同的函数。

    另外，
    如果定义 Lua 函数的过程中出现了错误 ——
    比如说，
    服务器发现传入的脚本中包含语法错误，
    那么服务器将向客户端返回一个脚本错误，
    并且不再执行后续的脚本求值步骤。

    服务器判断是否应该为 Lua 脚本定义函数的过程可以用图 IMAGE_CREATE_LUA_FUNCTION 来描述。

    .. graphviz::

        digraph {

            label = "\n 图 IMAGE_CREATE_LUA_FUNCTION    服务器为 Lua 脚本定义函数的过程";

            //

            node [shape = box];

            start [label = "服务器判断是否应该为 Lua 脚本定义函数"];

            defined_or_not [label = "给定名字的函数尚未存在于 Lua 环境中？", shape = diamond];

            define [label = "定义函数"];

            error_or_not [label = "定义出错？", shape = diamond];

            return_error [label = "向客户端返回错误信息"];

            next_step [label = "继续执行 EVAL 命令的后续步骤"];

            //

            start -> defined_or_not;

            defined_or_not -> define [label = "是"];

            define -> error_or_not;

            error_or_not -> return_error [label = "是"];

            defined_or_not -> next_step [label = "否"];

            error_or_not -> next_step [label = "否"];

        }


使用函数来保存客户端传入的脚本有以下好处：

- 执行脚本的步骤非常简单 —— 
  只要调用与脚本相对应的函数即可。

- 通过函数的局部性来让 Lua 环境保持清洁，
  减少了垃圾回收的工作量，
  并且避免了使用全局变量。

- 如果某个脚本所对应的函数在 Lua 环境中被定义过至少一次，
  那么只要记得这个脚本的 SHA1 校验和，
  服务器就可以在不知道脚本本身的情况下，
  直接通过调用 Lua 函数来执行脚本 ——
  这是 :ref:`EVALSHA` 命令的实现原理，
  稍后在介绍 :ref:`EVALSHA` 命令的实现时就会说到这一点。


将脚本保存到 ``lua_scripts`` 字典
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:ref:`EVAL` 命令要做的第二件事是将客户端传入的脚本保存到服务器的 ``lua_scripts`` 字典里面。

举个例子，
对于命令：

::

    EVAL "return 'hello world'" 0

来说，
服务器将在 ``lua_scripts`` 字典中新添加一个键值对，
其中键为 Lua 脚本的 SHA1 校验和：

::

    5332031c6b470dc5a0dd9b4bf2030dea6d65de91

而值则为 Lua 脚本本身：

::

    return 'hello world'

添加新键值对之后的 ``lua_scripts`` 字典如图 20-5 所示。

.. graphviz::

    digraph {

        label = "\n图 20-5    添加新键值对之后的 lua_scripts 字典";
        
        rankdir = LR;

        node [shape = record];

        //

        lua_scripts [label = "lua_scripts | ... | <hello> \"5332031c6b470dc5a0dd9b4bf2030dea6d65de91\" | ... "];

        hello [label = "\"return 'hello world'\"", shape = plaintext];

        lua_scripts:hello -> hello;

    }


执行脚本函数
^^^^^^^^^^^^^^^^

在为脚本定义函数，
并且将脚本保存到 ``lua_scripts`` 字典之后，
服务器还需要进行一些设置钩子、传入参数之类的准备动作，
才能正式开始执行脚本。

整个准备和执行脚本的过程如下：

1. 将 :ref:`EVAL` 命令中传入的键名（key name）参数和脚本参数保存到 ``KEYS`` 数组和 ``ARGV`` 数组，
   然后将这两个数组作为全局变量传入到 Lua 环境里面。

2. 为 Lua 环境装载超时处理钩子（hook），
   这个钩子可以在脚本出现超时运行情况时，
   让客户端通过 :ref:`SCRIPT_KILL` 命令停止脚本，
   或者通过 :ref:`SHUTDOWN` 命令直接关闭服务器。

3. 执行脚本函数。

4. 移除之前装载的超时钩子。

5. 将执行脚本函数所得的结果保存到客户端状态的输出缓冲区里面，
   等待服务器将结果返回给客户端。

6. 对 Lua 环境执行垃圾回收操作。

举个例子，
对于命令：

::

    EVAL "return 'hello world'" 0

来说，
服务器将执行以下动作：

1. 因为这个脚本没有给定任何键名参数或者脚本参数，
   所以服务器会跳过传值到 ``KEYS`` 数组或 ``ARGV`` 数组这一步。

2. 为 Lua 环境装载超时处理钩子。

3. 在 Lua 环境中执行 ``f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91`` 函数。

4. 移除超时钩子。

5. 将执行 ``f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91`` 函数所得的结果 ``"hello world"`` 保存到客户端状态的输出缓冲区里面。

6. 对 Lua 环境执行垃圾回收操作。
  
至此，
命令：

::

    EVAL "return 'hello world'" 0

的执行算是告一段落，
之后服务器只要将保存在输出缓冲区里面的执行结果返回给执行 :ref:`EVAL` 命令的客户端就可以了。

    

..
    图 IMAGE_EVAL_EXEC_PROCESS 展示了在执行 ``EVAL "return 'hello world'" 0`` 命令的过程中，
    发送 :ref:`EVAL` 命令的客户端、Redis 服务器和 Lua 环境之间的通讯过程。

    .. graphviz::

        digraph {

            label = "\n图 IMAGE_EVAL_EXEC_PROCESS    执行脚本时的通讯过程";

            //

            rankdir = LR;

            node [shape = box, height = 3.0];

            splines = ortho;

            //

            client [label = "客\n户\n端"];

            server [label = "服\n务\n器"];

            lua [label = "L\nu\na\n环\n境"];

            //

            client -> server [label = "1）发送命令请求\nEVAL \"return 'hello world'\" 0"];

            server -> lua [label = "2）为脚本 \"return 'hello world'\"\n创建函数"];

            server -> lua [label = "\n3）执行脚本函数"];

            lua -> server [label = "\n4）返回脚本函数的执行结果\n（一个 Lua 值）"];

            server -> client [label = "\n5）将 Lua 值转换成 Redis 回复\n然后发送给客户端"];

        }

    .. note::

        因为 Lua 环境是嵌入到服务器中的，
        而客户端是通过套接字连接到服务器上面的，
        所以在图 IMAGE_EVAL_EXEC_PROCESS 、图 IMAGE_FIRST_STEP_OF_EVAL 和图 IMAGE_SECOND_STEP_OF_EVAL 中，
        与 Lua 环境进行交互的服务器，
        和与客户端进行交互的服务器，
        两者的意义并不完全相同：
        
        - 对于客户端来说，
          图中所示的“服务器”就是我们平常说的 Redis 服务器。

        - 而对于 Lua 环境来说，
          图中所示的“服务器”代表的是“除 Lua 环境之外的其他服务器组件”，
          比如负责与 Lua 环境进行交互的 C 接口、事件处理器、命令执行器，
          等等。

..
    图 IMAGE_EVAL_EXEC_PROCESS 中展示的脚本中并没有执行 Redis 命令：
    当脚本里有调用 ``redis.call`` 或者 ``redis.pcall`` 函数来执行 Redis 命令时，
    脚本的执行过程会更复杂一些。

    举个例子，
    图 IMAGE_FIRST_STEP_OF_EVAL 和图 IMAGE_SECOND_STEP_OF_EVAL 展示了在执行 ``EVAL "return redis.call('DBSIZE')" 0`` 命令的过程中，
    发送 :ref:`EVAL` 命令的客户端、
    Redis 服务器、
    伪客户端、
    以及 Lua 环境之间的通讯过程。

    .. graphviz::

        digraph {

            label = "\n图 IMAGE_FIRST_STEP_OF_EVAL    执行带 Redis 命令的脚本时的通讯过程 （1） ";

            //

            rankdir = LR;

            node [shape = box, height = 3.0];

            splines = ortho;

            //

            client [label = "客\n户\n端"];

            server [label = "服\n务\n器"];

            //

            client -> server [label = "1）发送命令请求\nEVAL \"return redis.call('DBSIZE')\" 0"];

            server -> client [label = "\n9）将 Lua 值转换成 Redis 回复\n然后发送给客户端"];

        }

    .. graphviz::

        digraph {

            label = "\n图 IMAGE_SECOND_STEP_OF_EVAL    执行带 Redis 命令的脚本时的通讯过程 （2）";

            //

            rankdir = LR;

            node [shape = box, height = 3.0];

            splines = ortho;

            //

            server [label = "服\n务\n器"];

            lua [label = "L\nu\na\n环\n境", height = 2.0];

            fake_client [label = "伪\n客\n户\n端"];

            //

            server -> lua [label = "2）为脚本\n\"return redis.call('DBSZIE')\"\n创建函数"];

            server -> lua [label = "\n3）执行脚本函数"];

            lua -> fake_client [label = "4）调用\nredis.call('DBSIZE')"];

            server -> fake_client [dir = back, label = "5）发送 DBSIZE 命令请求"];

            server -> fake_client [label = "\n6）返回 DBSIZE 命令的回复"];

            fake_client -> lua [label = "\n7）将命令回复转换成\nLua 值，并返回给\nredis.call 函数"];

            lua -> server [label = "8）返回脚本函数的执行结果\n（一个 Lua 值）"];

        }

    因为 ``EVAL "return redis.call('DBSIZE')"`` 命令只是简单地调用了一次 ``DBSIZE`` 命令，
    所以在图 IMAGE_SECOND_STEP_OF_EVAL 中，
    Lua 环境和伪客户端只进行了一趟交互（图中的步骤 4 和步骤 7 ），
    当脚本中的 ``redis.call`` 调用或者 ``redis.pcall`` 调用次数增多时，
    Lua 环境和伪客户端的交互次数也会相应地增多，
    不过总体的交互方式和图 IMAGE_SECOND_STEP_OF_EVAL 中展示的一样。
