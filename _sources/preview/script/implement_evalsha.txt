EVALSHA 命令的实现
-----------------------

本章前面介绍 :ref:`EVAL` 命令的实现时说过，
每个被 :ref:`EVAL` 命令成功执行过的 Lua 脚本，
在 Lua 环境里面都有一个与这个脚本相对应的 Lua 函数，
函数的名字由 ``f_`` 前缀加上 40 个字符长的 SHA1 校验和组成：
比如 ``f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91`` 。

只要脚本对应的函数曾经在 Lua 环境里面定义过，
那么即使不知道脚本的内容本身，
客户端也可以根据脚本的 SHA1 校验和来调用脚本对应的函数，
从而达到执行脚本的目的 ——
这就是 :ref:`EVALSHA` 命令的实现原理。

可以用伪代码来描述这一原理：

.. code-block:: python

    def EVALSHA(sha1):
        
        # 拼接出函数的名字
        # 例如： f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91
        func_name = "f_" + sha1

        # 查看这个函数在 Lua 环境中是否存在
        if function_exists_in_lua_env(func_name):

            # 如果函数存在，那么执行它
            execute_lua_function(func_name)

        else:

            # 如果函数不存在，那么返回一个错误
            send_script_error("SCRIPT NOT FOUND")

举个例子，
当服务器执行完以下 :ref:`EVAL` 命令之后：

::

    redis> EVAL "return 'hello world'" 0
    "hello world"

Lua 环境里面就定义了以下函数：

.. code-block:: lua

    function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91()
        return 'hello world'
    end

当客户端执行以下 :ref:`EVALSHA` 命令时：

::

    redis> EVALSHA "5332031c6b470dc5a0dd9b4bf2030dea6d65de91" 0
    "hello world"

服务器首先根据客户端输入的 SHA1 校验和，
检查函数 ``f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91`` 是否存在于 Lua 环境中 —— 
得到的回应是该函数确实存在，
于是服务器执行 Lua 环境中的 ``f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91`` 函数，
并将结果 ``"hello world"`` 返回给客户端。
