Lua 环境协作组件
-----------------------

除了创建并修改 Lua 环境之外，
Redis 服务器还创建了两个用于与 Lua 环境进行协作的组件，
它们分别是负责执行 Lua 脚本中的 Redis 命令的伪客户端，
以及用于保存 Lua 脚本的 ``lua_scripts`` 字典。

接下来的两个小节将分别介绍这两个组件。


伪客户端
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

因为执行 Redis 命令必须有相应的客户端状态，
所以为了执行 Lua 脚本中包含的 Redis 命令，
Redis 服务器专门为 Lua 环境创建了一个伪客户端，
并由这个伪客户端负责处理 Lua 脚本中包含的所有 Redis 命令。

Lua 脚本使用 ``redis.call`` 函数或者 ``redis.pcall`` 函数执行一个 Redis 命令，
需要完成以下步骤：

1. Lua 环境将 ``redis.call`` 函数或者 ``redis.pcall`` 函数想要执行的命令传给伪客户端。

2. 伪客户端将脚本想要执行的命令传给命令执行器。

3. 命令执行器执行伪客户端传给它的命令，
   并将命令的执行结果返回给伪客户端。

4. 伪客户端接收命令执行器返回的命令结果，
   并将这个命令结果返回给 Lua 环境。

5. Lua 环境在接收到命令结果之后，
   将该结果返回给 ``redis.call`` 函数或者 ``redis.pcall`` 函数。

6. 接收到结果的 ``redis.call`` 函数或者 ``redis.pcall`` 函数会将命令结果作为函数返回值返回给脚本中的调用者。

图 20-2 展示了 Lua 脚本在调用 ``redis.call`` 函数时，
Lua 环境、伪客户端、命令执行器三者之间的通讯过程
（调用 ``redis.pcall`` 函数时产生的通讯过程也是一样的）。

.. graphviz::

    digraph {

        label = "\n图 20-2    Lua 脚本执行 Redis 命令时的通讯步骤";

        rankdir = LR;

        node [shape = record, height = 2.0];

        splines = ortho;

        //

        lua [label = "L\nu\na\n环\n境"];
        fake_client [label = "伪\n客\n户\n端"];
        eval [label = "命\n令\n执\n行\n器"];

        lua -> fake_client [label = "1) 传送 redis.call 函数\n想要执行的 Redis 命令"]
        fake_client -> eval [label = "2) 将命令传给执行器执行"];
        lua -> fake_client [dir = back, label = "\n4) 将命令结果传回给 Lua 环境"];
        fake_client -> eval [dir = back, label = "\n3) 返回命令的执行结果"];
    }

举个例子，
图 20-3 展示了 Lua 脚本在执行以下命令时：

::

    redis> EVAL "return redis.call('DBSIZE')" 0
    (integer) 10086

Lua 环境、伪客户端、命令执行器三者之间的通讯过程。

.. graphviz::

    digraph {

        label = "\n图 20-3    Lua 脚本执行 DBSIZE 命令时的通讯步骤";

        rankdir = LR;

        node [shape = record, height = 2.0];

        splines = ortho;

        //

        lua [label = "L\nu\na\n环\n境"];
        fake_client [label = "伪\n客\n户\n端"];
        eval [label = "命\n令\n执\n行\n器"];

        lua -> fake_client [label = "1) 传送 DBSIZE 请求"]
        fake_client -> eval [label = "2) 将 DBSIZE 命令传给执行器执行"];
        lua -> fake_client [dir = back, label = "\n4) 将命令结果 10086 传回给 Lua 环境"];
        fake_client -> eval [dir = back, label = "\n3) 返回命令的执行结果 10086"];
    }


``lua_scripts`` 字典
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

除了伪客户端之外，
Redis 服务器为 Lua 环境创建的另一个协作组件是 ``lua_scripts`` 字典，
这个字典的键为某个 Lua 脚本的 SHA1 校验和（checksum），
而字典的值则是 SHA1 校验和对应的 Lua 脚本：

::

    struct redisServer {

        // ...

        dict *lua_scripts;

        // ...
    
    };

Redis 服务器会将所有被 :ref:`EVAL` 命令执行过的 Lua 脚本，
以及所有被 :ref:`SCRIPT_LOAD` 命令载入过的 Lua 脚本都保存到 ``lua_scripts`` 字典里面。

举个例子，
如果客户端向服务器发送以下命令：

::

    redis> SCRIPT LOAD "return 'hi'"
    "2f31ba2bb6d6a0f42cc159d2e2dad55440778de3"

    redis> SCRIPT LOAD "return 1+1"
    "a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bd9"

    redis> SCRIPT LOAD "return 2*2"
    "4475bfb5919b5ad16424cb50f74d4724ae833e72"

那么服务器的 ``lua_scripts`` 字典将包含被 :ref:`SCRIPT_LOAD` 命令载入的三个 Lua 脚本，
如图 20-4 所示。

.. graphviz::

    digraph {

        label = "\n 图 20-4    lua_scripts 字典示例";
        
        rankdir = LR;

        node [shape = record];

        //

        lua_scripts [label = "lua_scripts | ... | <1> \"2f31ba2bb6d6a0f42cc159d2e2dad55440778de3\" | <2> \"a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bd9\" | <3> \"4475bfb5919b5ad16424cb50f74d4724ae833e72\" | ... "];

        node [shape = plaintext];

        one [label = "\"return 'hi'\""];
        two [label = "\"return 1+1\""];
        three [label = "\"return 2*2\""];

        lua_scripts:1 -> one;
        lua_scripts:2 -> two;
        lua_scripts:3 -> three;
    }

``lua_scripts`` 字典有两个作用，
一个是实现 :ref:`SCRIPT_EXISTS` 命令，
另一个是实现脚本复制功能，
本章稍后将详细说明 ``lua_scripts`` 字典在这两个功能中的作用。
